<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Secure Server</title>
  <link rel="icon" type="image/x-icon" href="favicon.ico"> 
  <style>
    html {
      height: 100%;
    }
    body {
    background-color: black;
    color: #00FF00;
    font-family: 'Courier New', Courier, monospace;
    font-size: clamp(14px, 2.5vw, 15px); /* Slightly smaller max font-size for a more 'zoomed-out' feel */
    margin: 0;
    padding: 10px 5px 50px; /* Add bottom padding to prevent content from being hidden by the fixed footer */
    white-space: pre-wrap;
    position: relative;
    animation: flicker 0.2s infinite;
    min-height: 100%; /* Use min-height for better layout stability with virtual keyboards */
    box-sizing: border-box;
    }

    .terminal-container {
    max-width: 900px;
    margin: auto;
    }

    .ascii-art {
      /* Use clamp() to create a responsive font-size with min/max values */
      font-size: clamp(4px, 1.4vw, 13px);
      line-height: 1.1; /* Keep lines tight */
      white-space: pre; /* Preserve whitespace and prevent wrapping */
      overflow: hidden; /* Hide any minor overflow */
      padding: 10px 0;
      /* The filter from the parent #terminal is a bit strong for small text, so we reduce it */
      filter: drop-shadow(0 0 2px #00FF00);
    }

    #terminal {
    position: relative;
    z-index: 2;
    filter: drop-shadow(0 0 4px #00FF00);
    white-space: pre-wrap; /* Ensure newlines in text are respected */
    }

    .centered-line {
      text-align: center;
    }

    .input-line {
    display: flex;
    padding: 5px 0; /* Add some vertical space to the input line */
    }

    .input-line span {
    flex-shrink: 0;
    }

    .input-line input {
    background: black;
    border: none;
    color: #00FF00;
    font-family: inherit;
    font-size: inherit;
    outline: none;
    flex-grow: 1;
    }

    footer {
      position: fixed;
      left: 0;
      bottom: 0;
      width: 100%;
      text-align: center;
      padding: 15px 0;
      font-size: 12px;
      opacity: 0.6;
      /* Allow clicks to pass through to the body for focus */
      pointer-events: none;
    }

    /* CRT Flicker */
    @keyframes flicker {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.98; }
    60% { opacity: 0.95; }
    70% { opacity: 0.97; }
    80% { opacity: 0.96; }
    90% { opacity: 0.99; }
    }

    /* Scanlines */
    body::before {
    content: '';
    position: absolute;
    top: 0; left: 0;
    width: 100%;
    height: 100%;
    background: repeating-linear-gradient(
      to bottom,
      rgba(0, 255, 0, 0.05),
      rgba(0, 255, 0, 0.05) 2px,
      transparent 2px,
      transparent 4px
    );
    z-index: 1;
    pointer-events: none;
    }

    /* Radial glow for curvature */
    body::after {
    content: '';
    position: absolute;
    top: 0; left: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(circle at center, rgba(0, 255, 0, 0.05), transparent 70%);
    z-index: 0;
    pointer-events: none;
  }
  </style>
</head>
<body>
  <div class="terminal-container">
    <div id="terminal"></div>
    <div class="input-line">
      <span>&gt; </span>
      <input id="terminal-input" autofocus />
    </div>
  </div>
  <footer>
    &copy; 2025 Matthew Emil Iglody
  </footer>
  <script>
    const terminal = document.getElementById('terminal');
    const input = document.getElementById('terminal-input');

    const initialWelcomeHTML = `MATTHEW IGLODY | SECURE SERVER | (TM) SECLINK PROTOCOL
<div class="centered-line">------- ONE TIME PASSWORD ACCEPTED -------</div>
<pre class="ascii-art">                                                                                                    
    @@@.     @@@     -@@:             @@@                                                           
     @@@    @@@@@    @@@              @@@                                                           
     @@@    @@@@@    @@:    @@@@@@    @@@    @@@@@@.   @@@@@@@    @@@ @@@@@ @@@@@=     @@@@@@       
      @@@  @@@ @@%  @@@   @@@    @@#  @@@   @@@   @@  @@@   @@@@  @@@@. @@@@@  @@@   @@@   .@@:     
      @@@  @@. @@@  @@:   @@@@@@@@@@  @@@  @@@       @@@     @@@  @@@    @@@    @@#  @@@@@@@@@@     
       @@@@@@  .@@=@@@    @@@         @@@  @@@       @@@     @@@  @@@    @@@    @@#  @@@            
       @@@@@-   @@@@@:    @@@.        @@@   @@@   *@ =@@@   @@@#  @@@    @@@    @@#  @@@            
        @@@@    .@@@@      #@@@@@@@   @@@    @@@@@@+   @@@@@@@    @@@    @@@    @@#   @@@@@@@@      
</pre>
> WELCOME USER

<div class="centered-line">--- ACCESSING PROFESSIONAL PORTFOLIO SYSTEM ---</div>

INITIALIZING SYSTEM...
SYSTEM STATUS: STABLE
USER PRIVILEGES: READ/VIEW/NAVIGATE

> SYSTEM ONLINE.
> TYPE "help" FOR AVAILABLE COMMANDS.
`;

    // Focus the input when the user clicks/taps anywhere on the terminal body
    document.body.addEventListener('click', (event) => {
      // If the user clicks on something that is not the input itself, focus the input.
      // This is to avoid interfering with text selection inside the input field.
      if (event.target !== input) {
        input.focus();
      }
    });

    let awaitingResponseFor = null; // State for multi-step commands

    const commandHistory = [];

    const commandAliases = {
      'h': 'help',
      '?': 'help',
      'b': 'bio',
      'c': 'contact',
      'wh': 'workhistory',
      'jobs': 'workhistory',
      'exp': 'workhistory',
      'm': 'menu',
      'game': 'hack',
      'play': 'hack',
      'hm': 'hangman',
      'cv': 'transfer',
      'resume': 'transfer',
      'history': 'logs',
      'l': 'logs',
      'cls': 'clear',
      'q': 'exit',
      'quit': 'exit'
    };

    const logs = [
      "[LOG 1 - 07/24/2077 13:04:02] Overseer reports Vault 112 social conditioning protocol is proceeding as planned.",
      "[LOG 2 - 07/25/2077 08:45:30] Internal sensor calibration completed. Minor anomalies in oxygen circulation flagged.",
      "[LOG 3 - 07/25/2077 16:12:59] Unauthorized attempt to access cryo chamber controls. Technician ID #0043.",
      "[LOG 4 - 07/26/2077 00:03:11] ALERT: Security lockdown initiated. Emergency protocol ZETA-5 activated.",
      "[LOG 5 - 07/26/2077 06:27:41] Power fluctuation detected in Sector C3. Engineering dispatched.",
      "[LOG 6 - 07/26/2077 09:15:20] Overseer broadcast: 'Remain calm. This is a containment drill.'",
      "[LOG 7 - 07/26/2077 12:52:14] Multiple failed login attempts from unrecognized terminal.",
      "[LOG 8 - 07/26/2077 18:34:57] Cryo Pod #12 suspension terminated. Medical team dispatched.",
      "[LOG 9 - 07/27/2077 02:17:04] Temperature spike in cryogenics bay. Fire suppression holding.",
      "[LOG 10 - 07/27/2077 05:39:33] Coolant leak in sub-level. Repairs underway.",
      "[LOG 11 - 07/27/2077 08:00:00] Surface beacon pinged. No signal response. Possible comms malfunction.",
      "[LOG 12 - 07/27/2077 10:22:18] Vault entrance locked. Unrecognized biometric access attempt logged.",
      "[LOG 13 - 07/27/2077 13:14:45] Cafeteria nutrient dispenser malfunction. Manual override successful.",
      "[LOG 14 - 07/27/2077 15:48:02] Resident anxiety levels elevated. Increasing recreational programs.",
      "[LOG 15 - 07/27/2077 20:01:59] Motion detected in corridor 7-B. No personnel scheduled. Drone dispatched."
    ];

    const menuItems = [
      "1. Bio - [TYPE 'bio' to view]",
      "2. Contact - [TYPE 'contact' to view]",
      "3. Work History - [TYPE 'workhistory' to view]",
      "4. Security Breach Minigame - [TYPE 'hack' to play]",
      "5. Hangman - [TYPE 'hangman' to play]"
    ];

    const commandDescriptions = {
      'help': 'List available commands',
      'bio': 'Display my professional bio',
      'contact': 'Display my contact information',
      'workhistory': 'Display my professional work history',
      'menu': 'Display a list of portfolio items',
      'hack': 'Initiate a security breach simulation',
      'hangman': 'Play a classic game of hangman',
      'transfer': 'Open my CV in a new tab',
      'logs': 'Display command history with timestamps',
      'clear': 'Clear the terminal and reset to welcome screen',
      'exit': 'Close the terminal interface'
    };

    const workHistoryDetails = {
      '1': {
        title: '2014-2016 | Desktop Support Technician | Good Samaritan Regional Medical Center, Suffern, NY',
        description: 'Placeholder text for your first role. Describe your responsibilities and achievements here.'
      },
      '2': {
        title: '2016-2019 | Solutions Analyst II - Radiology IT | NYU Langone Health, New York, NY',
        description: 'Placeholder text for your second role. Describe your responsibilities and achievements here.'
      },
      '3': {
        title: '2019-2022 | Senior Analyst I - Radiology IT | NYU Lanogne Health, New York, NY',
        description: 'Placeholder text for your third role. Describe your responsibilities and achievements here.'
      },
      '4': {
        title: '2022-2024 | Senior Analyst - Research IT | NYU Grossman School of Medicine, New York, NY',
        description: 'Placeholder text for your fourth role. Describe your responsibilities and achievements here.'
      }
    };

    const hackGameData = {
      words: ['SYSTEMS', 'ROUTERS', 'GATEWAY', 'NETWORK', 'CIRCUIT', 'ANALYZE', 'CONNECT', 'FIREWALL', 'PROTOCOL', 'DATABASE'],
      attempts: 4
    };

    let hackGameState = {};

    const hangmanGameData = {
      words: ['JAVASCRIPT', 'TERMINAL', 'PORTFOLIO', 'DEVELOPER', 'ENGINEER', 'PROTOCOL', 'AUTHENTICATE', 'ENCRYPTION', 'NETWORK', 'SERVER'],
      stages: [
/* 0 mistakes */
`
  +---+
  |   |
      |
      |
      |
      |
=========`,
/* 1 mistake */
`
  +---+
  |   |
  O   |
      |
      |
      |
=========`,
/* 2 mistakes */
`
  +---+
  |   |
  O   |
  |   |
      |
      |
=========`,
/* 3 mistakes */
`
  +---+
  |   |
  O   |
 /|   |
      |
      |
=========`,
/* 4 mistakes */
`
  +---+
  |   |
  O   |
 /|\\  |
      |
      |
=========`,
/* 5 mistakes */
`
  +---+
  |   |
  O   |
 /|\\  |
 /    |
      |
=========`,
/* 6 mistakes */
`
  +---+
  |   |
  O   |
 /|\\  |
 / \\  |
      |
=========`
      ]
    };

    let hangmanGameState = {};

    function printWelcomeMessage() {
      terminal.innerHTML = initialWelcomeHTML;
    }

    function appendTextToTerminal(text) {
      // Appending a text node is safer than innerHTML and respects the `white-space: pre-wrap` style.
      terminal.appendChild(document.createTextNode(text));
    }

    function typewriterEffect(text, onComplete) {
      let i = 0;
      input.disabled = true; // Disable input while typing

      // Create a dedicated container for the typewriter text. This prevents
      // re-rendering the entire terminal on each character and is more performant.
      const typewriterContainer = document.createElement('span');
      terminal.appendChild(typewriterContainer);

      const typingInterval = setInterval(() => {
        if (i < text.length) {
          typewriterContainer.textContent += text.charAt(i);
          i++;
          window.scrollTo(0, document.body.scrollHeight);
        } else {
          clearInterval(typingInterval);
          if (onComplete) onComplete();
        }
      }, 30); // Adjust typing speed here (in milliseconds)
    }

    function downloadTranscript() {
      // We grab the innerText of the terminal, but add a final message.
      const transcriptContent = terminal.innerText + "\n\n--- TRANSCRIPT END ---";
      const blob = new Blob([transcriptContent], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      link.download = `terminal-session-${timestamp}.txt`;
      link.href = url;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      appendTextToTerminal(`\nDownloading transcript...`);
    }

    function displayHangmanState() {
      const wordDisplay = hangmanGameState.word
        .split('')
        .map(letter => (hangmanGameState.guessedLetters.includes(letter) ? letter : '_'))
        .join(' ');

      const stageArt = hangmanGameData.stages[hangmanGameState.mistakes];
      const guessedDisplay = `Guessed: ${hangmanGameState.guessedLetters.join(', ')}`;
      
      const output = `\n${stageArt}\n\n${wordDisplay}\n\n${guessedDisplay}\n\nEnter a letter:`;
      appendTextToTerminal(output);
    }

    function startHangmanGame() {
      awaitingResponseFor = 'hangman_game';
      const word = hangmanGameData.words[Math.floor(Math.random() * hangmanGameData.words.length)];
      hangmanGameState = {
        word: word,
        guessedLetters: [],
        mistakes: 0
      };

      const gameScreen = `...INITIALIZING HANGMAN PROTOCOL...\nGuess the word. You have ${hangmanGameData.stages.length - 1} wrong guesses allowed.`;
      typewriterEffect(gameScreen, () => {
        displayHangmanState();
        input.disabled = false;
        input.focus();
      });
    }

    function handleHangmanGuess(guess) {
      guess = guess.toUpperCase();

      // --- Input Validation ---
      if (guess.length !== 1 || !/[A-Z]/.test(guess)) {
        appendTextToTerminal(`\n> Invalid input. Please enter a single letter.\n`);
        return;
      }
      if (hangmanGameState.guessedLetters.includes(guess)) {
        appendTextToTerminal(`\n> You already guessed the letter '${guess}'. Try another.\n`);
        return;
      }

      // --- Process Guess ---
      hangmanGameState.guessedLetters.push(guess);

      if (!hangmanGameState.word.includes(guess)) {
        hangmanGameState.mistakes++;
        appendTextToTerminal(`\n> INCORRECT!`);
      } else {
        appendTextToTerminal(`\n> CORRECT!`);
      }

      // --- Check for Win/Loss ---
      const wordIsGuessed = hangmanGameState.word.split('').every(letter => hangmanGameState.guessedLetters.includes(letter));

      if (wordIsGuessed) {
        endHangmanGame(true);
        return;
      }

      if (hangmanGameState.mistakes >= hangmanGameData.stages.length - 1) {
        endHangmanGame(false);
        return;
      }

      // --- Continue Game ---
      displayHangmanState();
    }

    function endHangmanGame(won) {
      awaitingResponseFor = null;
      const finalWordDisplay = `\nThe word was: ${hangmanGameState.word}`;
      appendTextToTerminal(finalWordDisplay);
      
      const message = won 
        ? "\n...SUCCESS...\nYOU SURVIVED." 
        : `\n...FAILURE...\n${hangmanGameData.stages[hangmanGameState.mistakes]}\nGAME OVER.`;
        
      typewriterEffect(message, () => {
        appendTextToTerminal("\n\n");
        input.disabled = false;
        input.focus();
      });
    }

    function startHackGame() {
      awaitingResponseFor = 'hack_game';
      const password = hackGameData.words[Math.floor(Math.random() * hackGameData.words.length)];
      hackGameState = {
        password: password,
        attemptsLeft: hackGameData.attempts
      };

      const gameScreen = `...DECRYPTING...\nPASSWORD REQUIRED.\n${hackGameState.attemptsLeft} ATTEMPTS REMAINING.\n\n${hackGameData.words.join('   ')}\n\nENTER PASSWORD:`;
      typewriterEffect(gameScreen, () => {
        input.disabled = false;
        input.focus();
      });
    }

    function handleHackGuess(guess) {
      guess = guess.toUpperCase();
      if (!hackGameData.words.includes(guess)) {
        appendTextToTerminal(`\n> SYNTAX ERROR. UNKNOWN WORD.\n`);
        return;
      }

      hackGameState.attemptsLeft--;

      if (guess === hackGameState.password) {
        endHackGame(true);
        return;
      }

      if (hackGameState.attemptsLeft <= 0) {
        endHackGame(false);
        return;
      }

      let likeness = 0;
      for (let i = 0; i < guess.length; i++) {
        if (i < hackGameState.password.length && guess[i] === hackGameState.password[i]) {
          likeness++;
        }
      }
      appendTextToTerminal(`\n> ACCESS DENIED.\n> LIKENESS=${likeness}\n> ${hackGameState.attemptsLeft} ATTEMPTS REMAINING.\n`);
    }

    function endHackGame(won) {
      awaitingResponseFor = null;
      const message = won ? "\n...PASSWORD ACCEPTED...\nFIREWALL DISABLED.\nSYSTEM ACCESS GRANTED." : `\n...LOCKOUT INITIATED...\nTERMINAL LOCKED.\n\n> INTRUSION ATTEMPT LOGGED.`;
      typewriterEffect(message, () => {
        appendTextToTerminal("\n\n");
        input.disabled = false;
        input.focus();
      });
    }

    function handleResponse(response) {
      switch (awaitingResponseFor) {
        case 'exit_confirm':
          if (response === 'y' || response === 'yes') {
            appendTextToTerminal(`\nWould you like a transcript of your activity? (y/n)`);
            awaitingResponseFor = 'transcript_prompt';
          } else {
            appendTextToTerminal(`\nExit cancelled.\n\n`);
            awaitingResponseFor = null;
          }
          break;
        case 'transcript_prompt':
          if (response === 'y' || response === 'yes') {
            downloadTranscript();
          }
          // Instead of exiting, ask for final confirmation.
          appendTextToTerminal(`\n\nAre you sure you want to terminate the session? (y/n)`);
          awaitingResponseFor = 'final_exit_confirm';
          break;
        case 'final_exit_confirm':
          if (response === 'y' || response === 'yes') {
            appendTextToTerminal(`\n\nSESSION TERMINATED.\nGOODBYE.`);
            input.disabled = true;
            setTimeout(() => window.close(), 2000);
            awaitingResponseFor = null;
          } else {
            appendTextToTerminal(`\nExit cancelled.\n\n`);
            awaitingResponseFor = null;
          }
          break;
        case 'workhistory_select':
          if (response === 'back') {
            appendTextToTerminal(`\nReturning to main prompt.\n\n`);
            awaitingResponseFor = null;
            break;
          }
          const job = workHistoryDetails[response];
          if (job) {
            awaitingResponseFor = null; // Valid selection, so we're done with the prompt.
            const fullText = `${job.title}\n----------------------------------------\n${job.description}`;
            typewriterEffect(fullText, () => {
              appendTextToTerminal("\n\n");
              input.disabled = false;
              input.focus();
            });
          } else {
            appendTextToTerminal(`\nInvalid selection. Please enter a number from the list or type 'back' to return.\n\n`);
            // Don't reset awaitingResponseFor, so the user can try again.
          }
          break;
        case 'hangman_game':
          handleHangmanGuess(response);
          break;
        case 'hack_game':
          handleHackGuess(response);
          break;
      }
    }

    let historyIndex = 0;

    input.addEventListener('keydown', function(event) {
      const currentInput = input.value.trim();
      const currentInputLower = currentInput.toLowerCase();

      // Handle up/down arrow for command history
      if (event.key === 'ArrowUp') {
        event.preventDefault();
        if (historyIndex > 0) {
          historyIndex--;
          input.value = commandHistory[historyIndex].text;
          // Move cursor to the end of the input for a better user experience
          setTimeout(() => input.setSelectionRange(input.value.length, input.value.length), 0);
        }
      } else if (event.key === 'ArrowDown') {
        event.preventDefault();
        if (historyIndex < commandHistory.length - 1) {
          historyIndex++;
          input.value = commandHistory[historyIndex].text;
          setTimeout(() => input.setSelectionRange(input.value.length, input.value.length), 0);
        } else {
          // If we are at the end of history, going down again clears the input for a new command
          historyIndex = commandHistory.length;
          input.value = '';
        }
      }
      // Handle Tab for command completion
      else if (event.key === 'Tab') {
        event.preventDefault();
        if (currentInputLower === '') return;

        const allPossibleCommands = [...Object.keys(commands), ...Object.keys(commandAliases)];
        const matches = allPossibleCommands.filter(c => c.startsWith(currentInputLower));

        if (matches.length === 1) {
          input.value = matches[0];
        } else if (matches.length > 1) {
          // Find the longest common prefix among all matches
          let sortedMatches = [...matches].sort();
          let first = sortedMatches[0];
          let last = sortedMatches[sortedMatches.length - 1];
          let i = 0;
          while (i < first.length && first.charAt(i) === last.charAt(i)) {
            i++;
          }
          const commonPrefix = first.substring(0, i);
          if (commonPrefix.length > currentInput.length) {
            input.value = commonPrefix;
          }
        }
      }
      // Handle Enter to submit command
      else if (event.key === 'Enter') {
        if (currentInput === '') return;

        appendTextToTerminal(`\n> ${currentInput}`); // Display original casing

        if (awaitingResponseFor) {
          appendTextToTerminal(`\n`);
          handleResponse(currentInputLower);
        } else {
          appendTextToTerminal(`\n`);
          commandHistory.push({ text: currentInput, timestamp: new Date() });
          historyIndex = commandHistory.length; // Reset history index
          handleCommand(currentInputLower);
        }

        input.value = '';
        window.scrollTo(0, document.body.scrollHeight);
      }
    });

    printWelcomeMessage();

    const commands = {
      help: () => {
        let helpText = 'AVAILABLE COMMANDS:\n';
        Object.entries(commandDescriptions).forEach(([command, description]) => {
          const aliases = Object.keys(commandAliases).filter(alias => commandAliases[alias] === command);
          helpText += `- ${command}${aliases.length > 0 ? ` (or: ${aliases.join(', ')})` : ''} : ${description}\n`;
        });
        return helpText.trim();
      },
      bio: () => {
        const bioText = "Welcome to my professional digital footprint. I'm glad you could take the time to stop by and check it out. My name is Matthew Iglody and I am a mid-career professional who has been working in IT since College. The summer after my freshman year I began interning at Stryker orthopaedics and after graduating college I got my first job working in hospital IT near the town I grew up in.";
        typewriterEffect(bioText, () => {
          // This function runs after the typing is complete
          appendTextToTerminal("\n\n"); // Add spacing after the bio
          input.disabled = false; // Re-enable the input field
          input.focus(); // Focus on the input field for the next command
          window.scrollTo(0, document.body.scrollHeight);
        });
        return null; // Signal that output is handled asynchronously
      },
      contact: () => {
        const contactText = "Cell: 732-573-8567\nEmail: mattiglody@gmail.com";
        typewriterEffect(contactText, () => {
          // This function runs after the typing is complete
          appendTextToTerminal("\n\n"); // Add spacing after the contact info
          input.disabled = false; // Re-enable the input field
          input.focus(); // Focus on the input field for the next command
          window.scrollTo(0, document.body.scrollHeight);
        });
        return null; // Signal that output is handled asynchronously
      },
      workhistory: () => {
        awaitingResponseFor = 'workhistory_select';
        const jobList = Object.entries(workHistoryDetails)
          .map(([key, value]) => `${key}. ${value.title}`)
          .join('\n');
        return `WORK HISTORY:\n${jobList}\n\nEnter a number to learn more, or type 'back' to return.`;
      },
      hangman: () => {
        startHangmanGame();
        return null; // Signal that output is handled asynchronously
      },
      hack: () => {
        startHackGame();
        return null; // Signal that output is handled asynchronously
      },
      menu: () => menuItems.join("\n"),
      transfer: () => {
        const filePath = 'docs/Matthew_E_Iglody_2025_CV.pdf';
        // Open the file in a new tab. The browser's built-in PDF viewer will handle it.
        window.open(filePath, '_blank');
        return "ACCESSING DOCUMENT...\nOPENING CV IN NEW TAB.";
      },
      logs: () => {
        // Exclude the 'logs' command itself from the output for a cleaner history view.
        if (commandHistory.length <= 1) {
          return "No previous commands in history.";
        }
        return commandHistory.slice(0, -1).map(entry => {
          const time = entry.timestamp.toLocaleTimeString('en-US', { hour12: false });
          return `[${time}] ${entry.text}`;
        }).join("\n");
      },
      exit: () => {
        awaitingResponseFor = 'exit_confirm';
        return "Are you sure you want to exit? (y/n)";
      },
    };

    function handleCommand(cmd) {
      const resolvedCmd = commandAliases[cmd] || cmd;

      // The 'clear' command is special as it modifies the terminal directly
      if (resolvedCmd === 'clear') {
        printWelcomeMessage();
        return;
      }

      const commandFn = commands[resolvedCmd];
      if (!commandFn) {
        appendTextToTerminal(`Unrecognized command: '${cmd}'\nType 'help' (or 'h') for options.\n\n`);
        return;
      }

      const output = commandFn();

      // If a command returns null, it handles its own output (e.g., typewriter)
      if (output === null) return;

      // The 'help' command's output is multi-line, so it only needs one trailing newline for spacing.
      const trailingNewlines = (['help', 'exit', 'workhistory', 'hack'].includes(resolvedCmd)) ? "\n" : "\n\n";
      appendTextToTerminal(output + trailingNewlines);
    }
  </script>
</body>
</html>
