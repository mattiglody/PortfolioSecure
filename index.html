<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Secure Server</title>
  <!--
    A more robust favicon setup for maximum compatibility.
    The browser will pick the best one for its context (tab, bookmarks, etc.).
  -->
  <link rel="icon" href="favicon.svg" type="image/svg+xml"> <!-- Modern, high-quality SVG -->
  <link rel="apple-touch-icon" href="apple-touch-icon.png"> <!-- iOS home screen icon (180x180) -->
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
  <link rel="shortcut icon" href="favicon.ico"> <!-- Fallback for older browsers -->
  <meta name="theme-color" content="#000000">
  <style>
    html {
      height: 100%;
      overflow: hidden; /* Prevent root-level scrollbars */
    }
    body {
    background-color: black;
    color: #00FF00;
    font-family: 'Courier New', Courier, monospace;
    font-size: clamp(14px, 2.5vw, 15px); /* Slightly smaller max font-size for a more 'zoomed-out' feel */
    margin: 0;
    white-space: pre-wrap;
    /* The body itself should fill the html container */
    height: 100%;
    overflow: hidden; /* Prevent the main page from ever scrolling */
    animation: flicker 0.2s infinite;
    }

    .terminal-container {
      max-width: 900px;
      /* Add horizontal padding to indent the content from the edges */
      padding: 0 2em; /* Horizontal padding for centering */
      box-sizing: border-box;
      margin: auto;
      /* Use flexbox to create a sticky footer layout */
      display: flex;
      flex-direction: column;
      height: 100%; /* Fill the body's height */
    }

    .ascii-art {
      /* Use clamp() to create a responsive font-size with min/max values */
      font-size: clamp(4px, 1.4vw, 13px);
      text-align: center;
      line-height: 1.1; /* Keep lines tight */
      white-space: pre; /* Preserve whitespace and prevent wrapping */
      overflow: hidden; /* Hide any minor overflow */
      padding: 10px 0;
      /* The filter from the parent #terminal is a bit strong for small text, so we reduce it */
      filter: drop-shadow(0 0 2px #00FF00);
    }

    .content-wrapper {
      flex-grow: 1; /* Allow this area to grow and push the footer down */
      overflow-y: auto; /* This makes the wrapper scrollable */
      min-height: 0; /* Fix for flexbox items with overflowing content */
      box-sizing: border-box;
      padding-top: 0; /* Removed padding to move content higher */
      /* Hide scrollbar for different browsers */
      -ms-overflow-style: none;  /* IE and Edge */
      scrollbar-width: none;  /* Firefox */
    }
    .content-wrapper::-webkit-scrollbar {
      display: none; /* Chrome, Safari, Opera */
    }

    .content-wrapper.no-scroll-on-launch {
      overflow-y: hidden;
    }

    #terminal {
    position: relative;
    z-index: 2;
    filter: drop-shadow(0 0 4px #00FF00);
    white-space: pre-wrap; /* Ensure newlines in text are respected */
    }

    .centered-line {
      text-align: center;
    }

    .input-line {
    display: flex;
    /* Use margin to create a consistent space above the input line */
    /* Set margin to one line-height to create a full blank line of space */
    margin-top: 1.2em;
    }

    .input-line span {
    flex-shrink: 0;
    }

    #terminal-input {
    background: black;
    border: none;
    color: #00FF00;
    font-family: inherit;
    font-size: inherit;
    outline: none;
    flex-grow: 1;
    /* Allow the input area to wrap text */
    white-space: pre-wrap;
    word-break: break-word;
    /* Ensure it has a minimum height and consistent line height */
    min-height: 1.2em;
    line-height: 1.2em;
    padding: 0; /* Remove any default padding from the div */
    }

    footer {
      flex-shrink: 0; /* Prevent the footer from shrinking */
      text-align: center;
      padding: 15px 0;
      font-size: 12px;
      opacity: 0.6;
    }

    /* CRT Flicker */
    @keyframes flicker {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.98; }
    60% { opacity: 0.95; }
    70% { opacity: 0.97; }
    80% { opacity: 0.96; }
    90% { opacity: 0.99; }
    }

    /* Scanlines */
    body::before {
    content: '';
    position: absolute;
    top: 0; left: 0;
    width: 100%;
    height: 100%;
    background: repeating-linear-gradient(
      to bottom,
      rgba(0, 255, 0, 0.05),
      rgba(0, 255, 0, 0.05) 2px,
      transparent 2px,
      transparent 4px
    );
    z-index: 1;
    pointer-events: none;
    }

    /* Radial glow for curvature */
    body::after {
    content: '';
    position: absolute;
    top: 0; left: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(circle at center, rgba(0, 255, 0, 0.05), transparent 70%);
    z-index: 0;
    pointer-events: none;
  }

  /* --- GUI Styles --- */
  .gui-hidden {
    display: none;
  }

  .gui-visible {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.75); /* Dim the background */
    z-index: 100;
    animation: none; /* Don't flicker the GUI overlay */
  }

  /* --- Fade Out Styles --- */
  .fade-hidden {
    display: none;
  }

  #fade-to-black {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: black;
    z-index: 9999; /* On top of everything */
    opacity: 0;
    transition: opacity 1.5s ease-in;
    pointer-events: none;
  }

  .gui-window {
    position: absolute;
    /* Default centered position for desktop */
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: #00FF00; /* Use background to create the border color */
    border: none;
    box-shadow: 0 0 10px #00FF00;
    width: 85%;
    max-width: 420px;
    min-width: 250px;
    min-height: 150px;
    font-family: 'Courier New', Courier, monospace;
    padding: 1px; /* This padding creates a very thin border */
    cursor: move;
    display: flex;
    flex-direction: column;
  }

  .gui-title-bar {
    background-color: #00FF00;
    color: black;
    padding: 0 8px;
    font-weight: bold;
    display: flex;
    justify-content: space-between;
    align-items: center;
    line-height: 1; /* Set line height to minimum for compactness */
    cursor: move;
  }

  .gui-resize-handle {
    position: absolute;
    width: 15px;
    height: 15px;
    bottom: 0;
    right: 0;
    cursor: se-resize;
    z-index: 10; /* On top of the draggable area */
  }

  .gui-close-button {
    background: none;
    border: none;
    color: black;
    font-family: monospace;
    font-size: 14px; /* Make the button slightly smaller to reduce title bar height */
    font-weight: bold;
    cursor: pointer;
    padding: 0; /* Remove default button padding */
    line-height: 1; /* Ensure the button itself is compact */
  }

  .gui-content {
    background-color: black; /* Content area has a black background */
    color: #00FF00; /* Text inside is green */
    padding: 0 15px;
    flex-grow: 1; /* Allows content to fill available space when resizing */
    overflow: auto; /* Add scrollbar if content overflows */
    cursor: default;
    /* Hide scrollbar for different browsers */
    -ms-overflow-style: none;  /* IE and Edge */
    scrollbar-width: none;  /* Firefox */
  }
  .gui-content::-webkit-scrollbar { display: none; } /* Chrome, Safari, Opera */

  /* Specific styles for the picture viewer content area */
  #pic-content {
    display: flex;
    flex-direction: column;
    padding: 15px; /* Add vertical padding and override horizontal from .gui-content */
  }

  #pic-content img {
    flex-grow: 1; /* Allow the image to fill the available space */
    object-fit: contain; /* Scale the image to fit, preserving aspect ratio */
    /* These are important for flexbox to correctly size/shrink the image */
    min-height: 0;
    width: 100%; /* Ensure it takes up the container's width */
  }
  .gui-content p { margin: 0; line-height: 1.1; } /* Apply a tight line-height directly to the paragraph */
  .gui-content ul { list-style: none; padding: 0; margin: 0; }
  .gui-content li { margin-bottom: 0; line-height: 1.1; } /* Apply a tight line-height directly to list items */
  .gui-content a { color: #00FF00; text-decoration: none; cursor: pointer; }
  .gui-content a:hover { background-color: #00FF00; color: black; }

  /* --- Mobile Optimizations --- */
  @media (max-width: 768px) {
    .gui-window {
      width: 90vw;
      max-width: none;
      top: 25px;
      left: 50%;
      transform: translateX(-50%);
    }

    .terminal-container {
      padding: 0 1em; /* Reduce horizontal padding for more content space */
    }

    .ascii-art {
      display: none; /* Hide wide ASCII art on small screens as it won't fit */
    }

    body {
      /* Use a slightly larger font on mobile for better readability */
      font-size: clamp(15px, 4vw, 16px);
    }

    .input-line {
      /* Add some space at the very bottom to avoid the on-screen keyboard feeling too cramped */
      padding-bottom: 0.5em;
    }
  }
  </style>
</head>
<body>
  <div class="terminal-container">
    <div class="content-wrapper">
      <div id="terminal"></div>
      <div class="input-line">
        <span>&gt; </span>
        <div id="terminal-input" contenteditable="true"></div>
      </div>
    </div>
    <footer>
     <!-- &copy; 2025 Matthew Emil Iglody-->
    </footer>
  </div>

  <div id="gui-container" class="gui-hidden">
    <div id="gui-window" class="gui-window">
      <div id="gui-title-bar" class="gui-title-bar">
        <span>SYSTEM MENU</span>
        <button id="gui-close-button" class="gui-close-button">X</button>
      </div>
      <div id="gui-content" class="gui-content">
        <p>Select an option to execute the command:</p>
        <ul>
          <li><a href="#" data-command="bio">1. Read Bio</a></li>
          <li><a href="#" data-command="contact">2. View Contact Info</a></li>
          <li><a href="#" data-command="workhistory">3. View Work History</a></li>
          <li><a href="#" data-command="hack">4. Play Security Breach Minigame</a></li>
          <li><a href="#" data-command="hangman">5. Play Hangman</a></li>
          <li><a href="#" data-command="lockpick">6. Simulate Lockpicking</a></li>
        </ul>
      </div>
      <div id="gui-resize-handle" class="gui-resize-handle"></div>
    </div>
  </div>

  <div id="pic-container" class="gui-hidden">
    <div id="pic-window" class="gui-window">
      <div id="pic-title-bar" class="gui-title-bar">
        <span>IMAGE VIEWER</span>
        <button id="pic-close-button" class="gui-close-button">X</button>
      </div>
      <div id="pic-content" class="gui-content">
        <p>This is a placeholder for an image or other content.</p>
        <img src="pics/Matt_Caricature.PNG" alt="Matt_Headshot">
        <p>In the future, this could display an actual image, maybe even a gallery.</p>
      </div>
      <div id="pic-resize-handle" class="gui-resize-handle"></div>
    </div>
  </div>

  <div id="fade-to-black" class="fade-hidden"></div>

  <script>
    const terminal = document.getElementById('terminal');
    const input = document.getElementById('terminal-input');
    const contentWrapper = document.querySelector('.content-wrapper');

    const initialWelcomeHTML = `<div class="centered-line">SECURE SERVER LINK (TM)<br>MATTHEW IGLODY</div>
<div class="centered-line">-----ONE TIME PASSWORD ACCEPTED-----</div>
<pre class="ascii-art">                                                                                                    
    @@@.     @@@     -@@:             @@@                                                           
     @@@    @@@@@    @@@              @@@                                                           
     @@@    @@@@@    @@:    @@@@@@    @@@    @@@@@@.   @@@@@@@    @@@ @@@@@ @@@@@=     @@@@@@       
      @@@  @@@ @@%  @@@   @@@    @@#  @@@   @@@   @@  @@@   @@@@  @@@@. @@@@@  @@@   @@@   .@@:     
      @@@  @@. @@@  @@:   @@@@@@@@@@  @@@  @@@       @@@     @@@  @@@    @@@    @@#  @@@@@@@@@@     
       @@@@@@  .@@=@@@    @@@         @@@  @@@       @@@     @@@  @@@    @@@    @@#  @@@            
       @@@@@-   @@@@@:    @@@.        @@@   @@@   *@ =@@@   @@@#  @@@    @@@    @@#  @@@            
        @@@@    .@@@@      #@@@@@@@   @@@    @@@@@@+   @@@@@@@    @@@    @@@    @@#   @@@@@@@@      
</pre>

> ACCESSING PROFESSIONAL PORTFOLIO...

> INTERFACE PRIVILEGES: READ

> WELCOME USER

> TYPE "help" FOR AVAILABLE COMMANDS (not case sensitive)
`;

    // --- Global State & Element Refs ---
    const guiContainer = document.getElementById('gui-container');
    const guiCloseButton = document.getElementById('gui-close-button');
    const guiContent = document.getElementById('gui-content');
    const picContainer = document.getElementById('pic-container');
    const picCloseButton = document.getElementById('pic-close-button');
    const fadeOverlay = document.getElementById('fade-to-black');
    let activeTypingInterval = null; // To manage the typewriter effect
    let awaitingResponseFor = null; // State for multi-step commands
    const commandHistory = [];

    // Focus the input when the user clicks/taps anywhere on the terminal body
    document.body.addEventListener('click', (event) => {
      // If the user clicks on something that is not the input itself, focus the input.
      // This is to avoid interfering with text selection inside the input field.
      if (event.target !== input) {
        input.focus();
      }
    });

    // Global keydown listener for system-wide shortcuts
    document.addEventListener('keydown', function(event) {
      // Handle Ctrl+C for process cancellation
      if (event.ctrlKey && event.key.toLowerCase() === 'c') {
        // We only want to act if a process is running to avoid interfering with browser's native copy function.
        if (awaitingResponseFor || activeTypingInterval) {
          event.preventDefault();
          
          // Display the interrupt signal. Since the input field might be disabled,
          // we can't rely on its content. We'll just show the signal at the point of interruption.
          appendTextToTerminal('^C');
          
          cancelCurrentProcess();
        }
      }
      // Handle Escape key to close GUI windows
      else if (event.key === 'Escape' || event.key === 'Esc') {
        // Check if the main GUI menu is visible and close it
        if (guiContainer.classList.contains('gui-visible')) {
          event.preventDefault(); // Prevent any default browser action
          hideGui();
        }
        // Check if the picture viewer is visible and close it
        else if (picContainer.classList.contains('gui-visible')) {
          event.preventDefault(); // Prevent any default browser action
          hidePicWindow();
        }
      }
    });

    const commandAliases = {
      'h': 'help',
      '?': 'help',
      'b': 'bio',
      'c': 'contact',
      'wh': 'workhistory',
      'jobs': 'workhistory',
      'exp': 'workhistory',
      'li': 'linkedin',
      'm': 'menu',
      'game': 'hack',
      'play': 'hack',
      'hm': 'hangman',
      'lp': 'lockpick',
      'p': 'pic',
      'cv': 'transfer',
      'joke': 'lol',
      'resume': 'transfer',
      'history': 'logs',
      'l': 'logs',
      'cls': 'clear',
      'q': 'exit',
      'quit': 'exit',
      'stop': 'cancel'
    };

    const logs = [
      "[LOG 1 - 07/24/2077 13:04:02] Overseer reports Vault 112 social conditioning protocol is proceeding as planned.",
      "[LOG 2 - 07/25/2077 08:45:30] Internal sensor calibration completed. Minor anomalies in oxygen circulation flagged.",
      "[LOG 3 - 07/25/2077 16:12:59] Unauthorized attempt to access cryo chamber controls. Technician ID #0043.",
      "[LOG 4 - 07/26/2077 00:03:11] ALERT: Security lockdown initiated. Emergency protocol ZETA-5 activated.",
      "[LOG 5 - 07/26/2077 06:27:41] Power fluctuation detected in Sector C3. Engineering dispatched.",
      "[LOG 6 - 07/26/2077 09:15:20] Overseer broadcast: 'Remain calm. This is a containment drill.'",
      "[LOG 7 - 07/26/2077 12:52:14] Multiple failed login attempts from unrecognized terminal.",
      "[LOG 8 - 07/26/2077 18:34:57] Cryo Pod #12 suspension terminated. Medical team dispatched.",
      "[LOG 9 - 07/27/2077 02:17:04] Temperature spike in cryogenics bay. Fire suppression holding.",
      "[LOG 10 - 07/27/2077 05:39:33] Coolant leak in sub-level. Repairs underway.",
      "[LOG 11 - 07/27/2077 08:00:00] Surface beacon pinged. No signal response. Possible comms malfunction.",
      "[LOG 12 - 07/27/2077 10:22:18] Vault entrance locked. Unrecognized biometric access attempt logged.",
      "[LOG 13 - 07/27/2077 13:14:45] Cafeteria nutrient dispenser malfunction. Manual override successful.",
      "[LOG 14 - 07/27/2077 15:48:02] Resident anxiety levels elevated. Increasing recreational programs.",
      "[LOG 15 - 07/27/2077 20:01:59] Motion detected in corridor 7-B. No personnel scheduled. Drone dispatched."
    ];

    const jokes = [
      "Why don't programmers like nature? It has too many bugs.",
      "What's the object-oriented way to get wealthy? Inheritance.",
      "Why did the web developer go broke? Because he used up all his cache.",
      "I told my wife she was drawing her eyebrows too high. She looked surprised.",
      "Why don't scientists trust atoms? Because they make up everything!"
    ];

    const commandDescriptions = {
      'help': 'List available commands',
      'bio': 'Display my professional bio',
      'contact': 'Display my contact information',
      'workhistory': 'Display my professional work history',
      'linkedin': 'Open my LinkedIn profile in a new tab',
      'menu': 'Display a list of portfolio items',
      'hack': 'Initiate a security breach simulation',
      'hangman': 'Play a classic game of hangman',
      'lockpick': 'Simulate a simple lockpicking minigame',
      'pic': 'Display a placeholder image viewer',
      'lol': 'Tell a random joke',
      'transfer': 'Open my CV in a new tab',
      'logs': 'Display command history with timestamps',
      'clear': 'Clear the terminal and reset to welcome screen',
      'exit': 'Close the terminal interface',
      'cancel': 'Cancel the current running process or command (or use Ctrl+C)'
    };

    const workHistoryDetails = {
      '1': {
        title: '2014-2016 | Desktop Support Technician | Good Samaritan Regional Medical Center, Suffern, NY',
        description: 'Placeholder text for your first role. Describe your responsibilities and achievements here.'
      },
      '2': {
        title: '2016-2019 | Solutions Analyst II - Radiology IT | NYU Langone Health, New York, NY',
        description: 'Placeholder text for your second role. Describe your responsibilities and achievements here.'
      },
      '3': {
        title: '2019-2022 | Senior Analyst I - Radiology IT | NYU Lanogne Health, New York, NY',
        description: 'Placeholder text for your third role. Describe your responsibilities and achievements here.'
      },
      '4': {
        title: '2022-2024 | Senior Analyst - Research IT | NYU Grossman School of Medicine, New York, NY',
        description: 'Placeholder text for your fourth role. Describe your responsibilities and achievements here.'
      }
    };

    const bioTextPart1 = "Welcome to my professional digital footprint. I'm glad you could take the time to stop by and check it out. My name is Matthew Iglody and I am a mid-career professional who has been working in IT since College. The summer after my freshman year I began interning at Stryker orthopaedics and after graduating college I got my first job working in hospital IT near the town I grew up in.";
    const bioTextPart2 = "[Placeholder for the rest of the bio text. You can fill this in later with more details about your career progression and skills.]";

    const hackGameData = {
      words: ['SYSTEMS', 'ROUTERS', 'GATEWAY', 'NETWORK', 'CIRCUIT', 'ANALYZE', 'CONNECT', 'FIREWALL', 'PROTOCOL', 'DATABASE'],
      attempts: 4
    };

    let hackGameState = {};

    const hangmanGameData = {
      words: ['JAVASCRIPT', 'TERMINAL', 'PORTFOLIO', 'DEVELOPER', 'ENGINEER', 'PROTOCOL', 'AUTHENTICATE', 'ENCRYPTION', 'NETWORK', 'SERVER'],
      stages: [
/* 0 mistakes */
`
  +---+
  |   |
      |
      |
      |
      |
=========`,
/* 1 mistake */
`
  +---+
  |   |
  O   |
      |
      |
      |
=========`,
/* 2 mistakes */
`
  +---+
  |   |
  O   |
  |   |
      |
      |
=========`,
/* 3 mistakes */
`
  +---+
  |   |
  O   |
 /|   |
      |
      |
=========`,
/* 4 mistakes */
`
  +---+
  |   |
  O   |
 /|\\  |
      |
      |
=========`,
/* 5 mistakes */
`
  +---+
  |   |
  O   |
 /|\\  |
 /    |
      |
=========`,
/* 6 mistakes */
`
  +---+
  |   |
  O   |
 /|\\  |
 / \\  |
      |
=========`
      ]
    };

    let hangmanGameState = {};
    let lockpickGameState = {};

    function printWelcomeMessage() {
      terminal.innerHTML = initialWelcomeHTML;
    }

    function appendTextToTerminal(text) {
      // Appending a text node is safer than innerHTML and respects the `white-space: pre-wrap` style.
      terminal.appendChild(document.createTextNode(text));
    }

    function showGui() {
      // Reset window position to center before showing
      const guiWindow = document.getElementById('gui-window'); // Keep this for specific window reset
      // By clearing inline styles, the window reverts to its CSS-defined
      // position, which respects the media query for mobile/desktop.
      guiWindow.style.top = '';
      guiWindow.style.left = '';
      guiWindow.style.transform = '';

      guiContainer.classList.remove('gui-hidden');
      guiContainer.classList.add('gui-visible');
      input.contentEditable = 'false'; // Disable terminal input while GUI is open
    }

    function hideGui() {
      guiContainer.classList.add('gui-hidden');
      guiContainer.classList.remove('gui-visible');
      input.contentEditable = 'true'; // Re-enable terminal input
      input.focus();
    }

    function showPicWindow() {
      const picWindow = document.getElementById('pic-window');
      // By clearing inline styles, the window reverts to its CSS-defined
      // position, which respects the media query for mobile/desktop.
      picWindow.style.top = '';
      picWindow.style.left = '';
      picWindow.style.transform = '';

      picContainer.classList.remove('gui-hidden');
      picContainer.classList.add('gui-visible');
      input.contentEditable = 'false';
    }

    function hidePicWindow() {
      picContainer.classList.add('gui-hidden');
      picContainer.classList.remove('gui-visible');
      input.contentEditable = 'true';
      input.focus();
    }

    
    function simulateCommand(command) {
      hideGui();
      appendTextToTerminal(`\n> ${command}\n`);
      commandHistory.push({ text: command, timestamp: new Date() });
      historyIndex = commandHistory.length;
      handleCommand(command);
      contentWrapper.scrollTop = contentWrapper.scrollHeight;
    }

    function typewriterEffect(text, onComplete) {
      if (activeTypingInterval) {
        clearInterval(activeTypingInterval);
      }
      let i = 0;
      input.contentEditable = 'false'; // Disable input while typing

      // Create a dedicated container for the typewriter text. This prevents
      // re-rendering the entire terminal on each character and is more performant.
      const typewriterContainer = document.createElement('span');
      terminal.appendChild(typewriterContainer);

      activeTypingInterval = setInterval(() => {
        if (i < text.length) {
          typewriterContainer.textContent += text.charAt(i);
          i++;
          contentWrapper.scrollTop = contentWrapper.scrollHeight;
        } else {
          clearInterval(activeTypingInterval);
          activeTypingInterval = null; // Reset the handle
          if (onComplete) onComplete();
        }
      }, 30); // Adjust typing speed here (in milliseconds)
    }

    function cancelCurrentProcess() {
      if (!awaitingResponseFor && !activeTypingInterval) {
        return false; // Nothing to cancel
      }

      if (activeTypingInterval) {
        clearInterval(activeTypingInterval);
        activeTypingInterval = null;
      }
      awaitingResponseFor = null;

      appendTextToTerminal(`\n\n[PROCESS CANCELLED]\nReturning to main prompt.\n`);
      input.contentEditable = 'true';
      input.focus();
      return true;
    }

    function moveCursorToEnd(element) {
      const range = document.createRange();
      const selection = window.getSelection();
      range.selectNodeContents(element);
      range.collapse(false); // false collapses to the end
      selection.removeAllRanges();
      selection.addRange(range);
      element.focus();
    }

    function downloadTranscript() {
      // We grab the innerText of the terminal, but add a final message.
      const transcriptContent = terminal.innerText + "\n\n--- TRANSCRIPT END ---";
      const blob = new Blob([transcriptContent], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      link.download = `terminal-session-${timestamp}.txt`;
      link.href = url;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      appendTextToTerminal(`\nDownloading transcript...`);
    }

    function displayHangmanState() {
      const wordDisplay = hangmanGameState.word
        .split('')
        .map(letter => (hangmanGameState.guessedLetters.includes(letter) ? letter : '_'))
        .join(' ');

      const stageArt = hangmanGameData.stages[hangmanGameState.mistakes];
      const guessedDisplay = `Guessed: ${hangmanGameState.guessedLetters.join(', ')}`;

      const output = `\n${stageArt}\n\n${wordDisplay}\n\n${guessedDisplay}\n\nEnter a letter:`;
      appendTextToTerminal(output);
    }

    function startHangmanGame() {
      awaitingResponseFor = 'hangman_game';
      const word = hangmanGameData.words[Math.floor(Math.random() * hangmanGameData.words.length)];
      hangmanGameState = {
        word: word,
        guessedLetters: [],
        mistakes: 0
      };

      const gameScreen = `...INITIALIZING HANGMAN PROTOCOL...\nGuess the word. You have ${hangmanGameData.stages.length - 1} wrong guesses allowed.`;
      typewriterEffect(gameScreen, () => {
        displayHangmanState();
        input.contentEditable = 'true';
        input.focus();
      });
    }

    function handleHangmanGuess(guess) {
      guess = guess.toUpperCase();

      // --- Input Validation ---
      if (guess.length !== 1 || !/[A-Z]/.test(guess)) {
        appendTextToTerminal(`\n> Invalid input. Please enter a single letter.\n`);
        return;
      }
      if (hangmanGameState.guessedLetters.includes(guess)) {
        appendTextToTerminal(`\n> You already guessed the letter '${guess}'. Try another.\n`);
        return;
      }

      // --- Process Guess ---
      hangmanGameState.guessedLetters.push(guess);

      if (!hangmanGameState.word.includes(guess)) {
        hangmanGameState.mistakes++;
        appendTextToTerminal(`\n> INCORRECT!`);
      } else {
        appendTextToTerminal(`\n> CORRECT!`);
      }

      // --- Check for Win/Loss ---
      const wordIsGuessed = hangmanGameState.word.split('').every(letter => hangmanGameState.guessedLetters.includes(letter));

      if (wordIsGuessed) {
        endHangmanGame(true);
        return;
      }

      if (hangmanGameState.mistakes >= hangmanGameData.stages.length - 1) {
        endHangmanGame(false);
        return;
      }

      // --- Continue Game ---
      displayHangmanState();
    }

    function endHangmanGame(won) {
      awaitingResponseFor = null;
      const finalWordDisplay = `\nThe word was: ${hangmanGameState.word}`;
      appendTextToTerminal(finalWordDisplay);
      
      const message = won 
        ? "\n...SUCCESS...\nYOU SURVIVED." 
        : `\n...FAILURE...\n${hangmanGameData.stages[hangmanGameState.mistakes]}\nGAME OVER.`;
        
      typewriterEffect(message, () => {
        appendTextToTerminal("\n");
        input.contentEditable = 'true';
        input.focus();
      });
    }

    function startLockpickGame() {
      awaitingResponseFor = 'lockpick_game';
      const target = Math.floor(Math.random() * 100) + 1;
      lockpickGameState = {
        targetPosition: target,
        attemptsLeft: 5
      };

      const gameScreen = `...INITIATING LOCKPICK SIMULATION...\nYou find a rusted footlocker. You have ${lockpickGameState.attemptsLeft} bobby pins.\nFind the sweet spot by entering a position [1-100].`;
      typewriterEffect(gameScreen, () => {
        appendTextToTerminal(`\nEnter position:`);
        input.contentEditable = 'true';
        input.focus();
      });
    }

    function handleLockpickAttempt(attempt) {
      const position = parseInt(attempt, 10);

      if (isNaN(position) || position < 1 || position > 100) {
        appendTextToTerminal(`\n> Invalid input. Please enter a number between 1 and 100.\n`);
        return;
      }

      if (position === lockpickGameState.targetPosition) {
        endLockpickGame(true);
        return;
      }

      lockpickGameState.attemptsLeft--;

      if (lockpickGameState.attemptsLeft <= 0) {
        appendTextToTerminal(`\n> *SNAP!* Your bobby pin breaks.`);
        endLockpickGame(false);
        return;
      }

      let feedback = "\n> ";
      feedback += (position > lockpickGameState.targetPosition) 
        ? "The pin meets heavy resistance. You've pushed it too far.\n> "
        : "The pin feels loose. Not enough pressure.\n> ";

      const diff = Math.abs(lockpickGameState.targetPosition - position);
      if (diff <= 5) {
        feedback += "You feel a slight give... you're very close.";
      } else if (diff <= 15) {
        feedback += "You hear a faint metallic scrape. Getting warmer.";
      } else {
        feedback += "Nothing but solid tension. You're way off.";
      }

      appendTextToTerminal(`${feedback}\n> You have ${lockpickGameState.attemptsLeft} bobby pins left.\n\nEnter position:`);
    }

    function endLockpickGame(won) {
      awaitingResponseFor = null;
      const message = won 
        ? "\n...*CLICK*...\nThe lock springs open. You find a dusty old comic book." 
        : `\n...FAILURE...\nThe lock remains sealed.`;
        
      typewriterEffect(message, () => {
        appendTextToTerminal("\n");
        input.contentEditable = 'true';
        input.focus();
      });
    }

    function startHackGame() {
      awaitingResponseFor = 'hack_game';
      const password = hackGameData.words[Math.floor(Math.random() * hackGameData.words.length)];
      hackGameState = {
        password: password,
        attemptsLeft: hackGameData.attempts
      };

      const gameScreen = `...DECRYPTING...\nPASSWORD REQUIRED.\n${hackGameState.attemptsLeft} ATTEMPTS REMAINING.\n\n${hackGameData.words.join('   ')}\n\nENTER PASSWORD:`;
      typewriterEffect(gameScreen, () => {
        input.contentEditable = 'true';
        input.focus();
      });
    }

    function handleHackGuess(guess) {
      guess = guess.toUpperCase();
      if (!hackGameData.words.includes(guess)) {
        appendTextToTerminal(`\n> SYNTAX ERROR. UNKNOWN WORD.\n`);
        return;
      }

      hackGameState.attemptsLeft--;

      if (guess === hackGameState.password) {
        endHackGame(true);
        return;
      }

      if (hackGameState.attemptsLeft <= 0) {
        endHackGame(false);
        return;
      }

      let likeness = 0;
      for (let i = 0; i < guess.length; i++) {
        if (i < hackGameState.password.length && guess[i] === hackGameState.password[i]) {
          likeness++;
        }
      }
      appendTextToTerminal(`\n> ACCESS DENIED.\n> LIKENESS=${likeness}\n> ${hackGameState.attemptsLeft} ATTEMPTS REMAINING.\n`);
    }

    function endHackGame(won) {
      awaitingResponseFor = null;
      const message = won ? "\n...PASSWORD ACCEPTED...\nFIREWALL DISABLED.\nSYSTEM ACCESS GRANTED." : `\n...LOCKOUT INITIATED...\nTERMINAL LOCKED.\n\n> INTRUSION ATTEMPT LOGGED.`;
      typewriterEffect(message, () => {
        appendTextToTerminal("\n");
        input.contentEditable = 'true';
        input.focus();
      });
    }

    function makeDraggable(element, handle) {
      let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;

      const dragMouseDown = (e) => {
        // Prevent dragging when clicking on interactive elements (content, close button, resize handle)
        // Using classes makes this function reusable for any window.
        if (e.target.closest('.gui-content') || e.target.closest('.gui-close-button') || e.target.closest('.gui-resize-handle')) {
          return;
        }
        // If the element is centered with transform, convert to absolute pixel positioning for dragging
        if (element.style.transform) {
          const rect = element.getBoundingClientRect();
          element.style.transform = 'none';
          element.style.left = `${rect.left}px`;
          element.style.top = `${rect.top}px`;
        }

        e.preventDefault();
        // Get the initial cursor position
        if (e.type === 'touchstart') {
          pos3 = e.touches[0].clientX;
          pos4 = e.touches[0].clientY;
        } else {
          pos3 = e.clientX;
          pos4 = e.clientY;
        }
        document.addEventListener('mouseup', closeDragElement);
        document.addEventListener('touchend', closeDragElement);
        document.addEventListener('mousemove', elementDrag);
        document.addEventListener('touchmove', elementDrag);
      };

      const elementDrag = (e) => {
        e.preventDefault();
        const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
        const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
        pos1 = pos3 - clientX;
        pos2 = pos4 - clientY;
        pos3 = clientX;
        pos4 = clientY;
        element.style.top = (element.offsetTop - pos2) + "px";
        element.style.left = (element.offsetLeft - pos1) + "px";
      };

      const closeDragElement = () => {
        document.removeEventListener('mouseup', closeDragElement);
        document.removeEventListener('touchend', closeDragElement);
        document.removeEventListener('mousemove', elementDrag);
        document.removeEventListener('touchmove', elementDrag);
      };

      handle.addEventListener('mousedown', dragMouseDown);
      handle.addEventListener('touchstart', dragMouseDown);
    }

    function makeResizable(element, handle) {
      let initialX, initialY, initialWidth, initialHeight;

      const resizeMouseDown = (e) => {
        e.preventDefault();
        e.stopPropagation(); // Prevent triggering the drag behavior on the parent

        initialWidth = element.offsetWidth;
        initialHeight = element.offsetHeight;

        if (e.type === 'touchstart') {
          initialX = e.touches[0].clientX;
          initialY = e.touches[0].clientY;
        } else {
          initialX = e.clientX;
          initialY = e.clientY;
        }

        document.addEventListener('mousemove', elementResize);
        document.addEventListener('touchmove', elementResize, { passive: false });
        document.addEventListener('mouseup', stopResize);
        document.addEventListener('touchend', stopResize);
      };

      const elementResize = (e) => {
        if (e.type === 'touchmove') e.preventDefault();
        
        const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
        const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;

        element.style.width = (initialWidth + (clientX - initialX)) + 'px';
        element.style.height = (initialHeight + (clientY - initialY)) + 'px';
      };

      const stopResize = () => {
        document.removeEventListener('mousemove', elementResize);
        document.removeEventListener('touchmove', elementResize);
        document.removeEventListener('mouseup', stopResize);
        document.removeEventListener('touchend', stopResize);
      };

      handle.addEventListener('mousedown', resizeMouseDown);
      handle.addEventListener('touchstart', resizeMouseDown);
    }

    function handleResponse(response) {
      switch (awaitingResponseFor) {
        case 'transcript_prompt':
          if (response === 'y' || response === 'yes') {
            downloadTranscript();
          }
          // After handling the transcript, ask for final confirmation to exit.
          appendTextToTerminal(`\n\nAre you sure you want to terminate the session? (y/n)`);
          awaitingResponseFor = 'final_exit_confirm';
          break;
        case 'final_exit_confirm':
          if (response === 'y' || response === 'yes') {
            awaitingResponseFor = null;
            const exitMessage = `\n\nSESSION TERMINATED.\nGOODBYE.`;
            typewriterEffect(exitMessage, () => {
              // We visually end the session by fading to black. After the fade animation
              // completes, we will attempt to close the window.
              fadeOverlay.style.display = 'block';

              // Add a listener that will close the window once the fade is complete.
              fadeOverlay.addEventListener('transitionend', () => {
                window.close();
              }, { once: true });

              // A short delay ensures the 'display' change is rendered before the opacity transition starts.
              setTimeout(() => {
                fadeOverlay.style.opacity = '1';
              }, 50);
            });
          } else {
            appendTextToTerminal(`\nExit cancelled.\n`);
            awaitingResponseFor = null;
          }
          break;
        case 'bio_continue':
          if (response === 'y' || response === 'yes') {
            awaitingResponseFor = null; // Reset state before async operation
            typewriterEffect(`\n${bioTextPart2}`, () => {
              appendTextToTerminal("\n");
              input.contentEditable = 'true';
              input.focus();
            });
          } else {
            appendTextToTerminal(`\nReturning to main prompt.\n`);
            awaitingResponseFor = null;
          }
          break;
        case 'workhistory_select':
          if (response === 'back') {
            appendTextToTerminal(`\nReturning to main prompt.\n`);
            awaitingResponseFor = null;
            break;
          }
          const job = workHistoryDetails[response];
          if (job) {
            awaitingResponseFor = null; // Valid selection, so we're done with the prompt.
            const fullText = `${job.title}\n----------------------------------------\n${job.description}`;
            typewriterEffect(fullText, () => {
              appendTextToTerminal("\n");
              input.contentEditable = 'true';
              input.focus();
            });
          } else {
            appendTextToTerminal(`\nInvalid selection. Please enter a number from the list or type 'back' to return.\n`);
            // Don't reset awaitingResponseFor, so the user can try again.
          }
          break;
        case 'hangman_game':
          handleHangmanGuess(response);
          break;
        case 'hack_game':
          handleHackGuess(response);
          break;
        case 'lockpick_game':
          handleLockpickAttempt(response);
          break;
      }
    }

    let historyIndex = 0;

    input.addEventListener('keydown', function(event) {
      // Use innerText for contenteditable div
      const rawInput = input.innerText;
      const currentInput = rawInput.trim();
      const currentInputLower = currentInput.toLowerCase();

      // Handle up/down arrow for command history
      if (event.key === 'ArrowUp') {
        event.preventDefault();
        if (historyIndex > 0) {
          historyIndex--;
          input.innerText = commandHistory[historyIndex].text;
          // Move cursor to the end of the input for a better user experience
          setTimeout(() => moveCursorToEnd(input), 0);
        }
      } else if (event.key === 'ArrowDown') {
        event.preventDefault();
        if (historyIndex < commandHistory.length - 1) {
          historyIndex++;
          input.innerText = commandHistory[historyIndex].text;
          setTimeout(() => moveCursorToEnd(input), 0);
        } else {
          // If we are at the end of history, going down again clears the input for a new command
          historyIndex = commandHistory.length;
          input.innerText = '';
        }
      }
      // Handle Tab for command completion
      else if (event.key === 'Tab') {
        event.preventDefault();
        if (currentInputLower === '') return;

        const allPossibleCommands = [...Object.keys(commands), ...Object.keys(commandAliases)];
        const matches = allPossibleCommands.filter(c => c.startsWith(currentInputLower));

        if (matches.length === 1) {
          input.innerText = matches[0];
          setTimeout(() => moveCursorToEnd(input), 0);
        } else if (matches.length > 1) {
          // Find the longest common prefix among all matches
          let sortedMatches = [...matches].sort();
          let first = sortedMatches[0];
          let last = sortedMatches[sortedMatches.length - 1];
          let i = 0;
          while (i < first.length && first.charAt(i) === last.charAt(i)) {
            i++;
          }
          const commonPrefix = first.substring(0, i);
          if (commonPrefix.length > currentInput.length) {
            input.innerText = commonPrefix;
            setTimeout(() => moveCursorToEnd(input), 0);
          }
        }
      }
      // Handle Enter to submit command
      else if (event.key === 'Enter') {
        event.preventDefault(); // Prevent adding a new line in the contenteditable div
        // On the first command, re-enable scrolling for the content area.
        contentWrapper.classList.remove('no-scroll-on-launch');

        if (currentInput === '') return;

        appendTextToTerminal(`\n> ${currentInput}`); // Display original casing

        const resolvedForCancel = commandAliases[currentInputLower] || currentInputLower;

        // --- Special 'cancel' command to interrupt processes ---
        if (resolvedForCancel === 'cancel') {
          if (!cancelCurrentProcess()) { // The typed command doesn't show ^C
            appendTextToTerminal(`\nNo active process to cancel.\n`);
          }
        } else if (awaitingResponseFor) {
          appendTextToTerminal(`\n`);
          handleResponse(currentInputLower);
        } else {
          appendTextToTerminal(`\n`);
          commandHistory.push({ text: currentInput, timestamp: new Date() });
          historyIndex = commandHistory.length; // Reset history index
          handleCommand(currentInputLower);
        }

        input.innerText = '';
        contentWrapper.scrollTop = contentWrapper.scrollHeight;
      }
    });

    // --- GUI Event Listeners ---
    // We add listeners for both 'click' and 'touchend' to ensure the GUI is
    // responsive on touch devices while maintaining compatibility with mouse input.
    // Calling preventDefault() in the handler for 'touchend' stops the browser
    // from firing a redundant 'click' event after a tap.
    const handleCloseClick = (event) => {
      event.preventDefault();
      hideGui();
    };
    guiCloseButton.addEventListener('click', handleCloseClick);
    guiCloseButton.addEventListener('touchend', handleCloseClick);

    const handlePicCloseClick = (event) => {
      event.preventDefault();
      hidePicWindow();
    };
    picCloseButton.addEventListener('click', handlePicCloseClick);
    picCloseButton.addEventListener('touchend', handlePicCloseClick);

    const handleMenuClick = (event) => {
      const target = event.target.closest('a');
      if (target && target.dataset.command) {
        event.preventDefault();
        const command = target.dataset.command;
        simulateCommand(command);
      }
    };
    guiContent.addEventListener('click', handleMenuClick);
    guiContent.addEventListener('touchend', handleMenuClick);

    makeDraggable(document.getElementById('gui-window'), document.getElementById('gui-window'));
    makeResizable(document.getElementById('gui-window'), document.getElementById('gui-resize-handle'));

    makeDraggable(document.getElementById('pic-window'), document.getElementById('pic-window'));
    makeResizable(document.getElementById('pic-window'), document.getElementById('pic-resize-handle'));

    printWelcomeMessage();
    // Initially disable scrolling in the content area for a clean launch.
    contentWrapper.classList.add('no-scroll-on-launch');

    const commands = {
      help: () => {
        const isMobile = window.innerWidth <= 768; // Match the CSS breakpoint

        const commandToAliases = Object.entries(commandAliases).reduce((acc, [alias, command]) => {
          (acc[command] = acc[command] || []).push(alias);
          return acc;
        }, {});

        let helpText = 'AVAILABLE COMMANDS:\n\n';

        if (isMobile) {
          // Mobile-friendly stacked view for better readability
          const labelWidth = 10;
          Object.entries(commandDescriptions).forEach(([command, description]) => {
            const aliases = (commandToAliases[command] || []).join(', ');
            helpText += `${'COMMAND:'.padEnd(labelWidth)}${command}\n`;
            if (aliases) {
              helpText += `${'ALIASES:'.padEnd(labelWidth)}${aliases}\n`;
            }
            helpText += `${'DESC:'.padEnd(labelWidth)}${description}\n\n`;
          });
        } else {
          // Desktop table view
          const commandColWidth = 12;
          const aliasesColWidth = 15;

          helpText += 'COMMAND'.padEnd(commandColWidth) + 'ALIASES'.padEnd(aliasesColWidth) + 'DESCRIPTION\n';
          helpText += '-------'.padEnd(commandColWidth) + '-------'.padEnd(aliasesColWidth) + '-----------\n';

          Object.entries(commandDescriptions).forEach(([command, description]) => {
            const aliases = (commandToAliases[command] || []).join(', ');
            helpText += `${command.padEnd(commandColWidth)}${aliases.padEnd(aliasesColWidth)}${description}\n`;
          });
        }
        return helpText.trim();
      },
      bio: () => {
        typewriterEffect(bioTextPart1, () => {
          // This function runs after the typing is complete
          appendTextToTerminal(`\n\nWould you like to continue reading? (y/n)`);
          awaitingResponseFor = 'bio_continue';
          input.contentEditable = 'true'; // Re-enable the input field
          input.focus(); // Focus on the input field for the next command
          contentWrapper.scrollTop = contentWrapper.scrollHeight;
        });
        return null; // Signal that output is handled asynchronously
      },
      contact: () => {
        const contactText = "Cell: 732-573-8567\nEmail: mattiglody@gmail.com";
        typewriterEffect(contactText, () => {
          // This function runs after the typing is complete
          appendTextToTerminal("\n"); // Add spacing after the contact info
          input.contentEditable = 'true'; // Re-enable the input field
          input.focus(); // Focus on the input field for the next command
          contentWrapper.scrollTop = contentWrapper.scrollHeight;
        });
        return null; // Signal that output is handled asynchronously
      },
      workhistory: () => {
        awaitingResponseFor = 'workhistory_select';
        const jobList = Object.entries(workHistoryDetails)
          .map(([key, value]) => `${key}. ${value.title}`)
          .join('\n');
        return `WORK HISTORY:\n${jobList}\n\nEnter a number to learn more, or type 'back' to return.`;
      },
      linkedin: () => {
        const url = 'https://www.linkedin.com/in/matthew-iglody/';
        window.open(url, '_blank');
        return "ACCESSING EXTERNAL LINK...\nREDIRECTING TO LINKEDIN PROFILE IN NEW TAB.";
      },
      lol: () => {
        const randomIndex = Math.floor(Math.random() * jokes.length);
        return jokes[randomIndex];
      },
      hangman: () => {
        startHangmanGame();
        return null; // Signal that output is handled asynchronously
      },
      lockpick: () => {
        startLockpickGame();
        return null; // Signal that output is handled asynchronously
      },
      hack: () => {
        startHackGame();
        return null; // Signal that output is handled asynchronously
      },
      menu: () => {
        showGui();
        return null; // GUI handles its own display, no text output needed
      },
      pic: () => {
        showPicWindow();
        return "Launching image viewer...";
      },
      transfer: () => {
        const filePath = 'docs/Matthew_E_Iglody_2025_CV.pdf';
        // Open the file in a new tab. The browser's built-in PDF viewer will handle it.
        window.open(filePath, '_blank');
        return "ACCESSING DOCUMENT...\nOPENING CV IN NEW TAB.";
      },
      logs: () => {
        // Exclude the 'logs' command itself from the output for a cleaner history view.
        if (commandHistory.length <= 1) {
          return "No previous commands in history.";
        }
        return commandHistory.slice(0, -1).map(entry => {
          const time = entry.timestamp.toLocaleTimeString('en-US', { hour12: false });
          return `[${time}] ${entry.text}`;
        }).join("\n");
      },
      exit: () => {
        awaitingResponseFor = 'transcript_prompt';
        return "Would you like a transcript of your activity? (y/n)";
      },
    };

    function handleCommand(cmd) {
      const resolvedCmd = commandAliases[cmd] || cmd;

      // The 'clear' command is special as it modifies the terminal directly
      if (resolvedCmd === 'clear') {
        printWelcomeMessage();
        return;
      }

      const commandFn = commands[resolvedCmd];
      if (!commandFn) {
        appendTextToTerminal(`Unrecognized command: '${cmd}'\nType 'help' (or 'h') for options.\n`);
        return;
      }

      const output = commandFn();

      // If a command returns null, it handles its own output (e.g., typewriter)
      if (output === null) return;

      // Add a single newline for consistent spacing before the next prompt.
      appendTextToTerminal(output + "\n");
    }
  </script>
</body>
</html>
