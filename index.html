<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Secure Server</title>
  <!--
    A more robust favicon setup for maximum compatibility.
    The browser will pick the best one for its context (tab, bookmarks, etc.).
  -->
  <link rel="icon" href="favicon.svg" type="image/svg+xml"> <!-- Modern, high-quality SVG -->
  <link rel="apple-touch-icon" href="apple-touch-icon.png"> <!-- iOS home screen icon (180x180) -->
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
  <link rel="shortcut icon" href="favicon.ico"> <!-- Fallback for older browsers -->
  <meta name="theme-color" content="#000000">
  <style>
    html {
      height: 100%;
      overflow: hidden; /* Prevent root-level scrollbars */
    }
    body {
    background-color: black;
    color: #00FF00;
    font-family: 'Courier New', Courier, monospace;
    font-size: clamp(14px, 2.5vw, 15px); /* Slightly smaller max font-size for a more 'zoomed-out' feel */
    margin: 0;
    white-space: pre-wrap;
    /* The body itself should fill the html container */
    height: 100%;
    overflow: hidden; /* Prevent the main page from ever scrolling */
    animation: flicker 0.2s infinite;
    }

    .terminal-container {
      max-width: 900px;
      /* Add horizontal padding to indent the content from the edges */
      padding: 0 2em; /* Horizontal padding for centering */
      box-sizing: border-box;
      margin: auto;
      /* Use flexbox to create a sticky footer layout */
      display: flex;
      flex-direction: column;
      height: 100%; /* Fill the body's height */
    }

    .ascii-art {
      /* Use clamp() to create a responsive font-size with min/max values */
      font-size: clamp(4px, 1.4vw, 13px);
      text-align: center;
      line-height: 1.1; /* Keep lines tight */
      white-space: pre; /* Preserve whitespace and prevent wrapping */
      overflow: hidden; /* Hide any minor overflow */
      padding: 10px 0;
      /* The filter from the parent #terminal is a bit strong for small text, so we reduce it */
      filter: drop-shadow(0 0 2px #00FF00);
    }

    .content-wrapper {
      flex-grow: 1; /* Allow this area to grow and push the footer down */
      overflow-y: auto; /* This makes the wrapper scrollable */
      min-height: 0; /* Fix for flexbox items with overflowing content */
      box-sizing: border-box;
      padding-top: 0; /* Removed padding to move content higher */
      /* Hide scrollbar for different browsers */
      -ms-overflow-style: none;  /* IE and Edge */
      scrollbar-width: none;  /* Firefox */
    }
    .content-wrapper::-webkit-scrollbar {
      display: none; /* Chrome, Safari, Opera */
    }

    .content-wrapper.no-scroll-on-launch {
      overflow-y: hidden;
    }

    #terminal {
    position: relative;
    z-index: 2;
    filter: drop-shadow(0 0 4px #00FF00);
    white-space: pre-wrap; /* Ensure newlines in text are respected */
    }

    .centered-line {
      text-align: center;
    }

    .input-line {
    display: flex;
    /* Use margin to create a consistent space above the input line */
    /* Set margin to one line-height to create a full blank line of space */
    margin-top: 1.2em;
    }

    .input-line span {
    flex-shrink: 0;
    }

    #terminal-input {
    background: black;
    border: none;
    color: #00FF00;
    font-family: inherit;
    font-size: inherit;
    outline: none;
    flex-grow: 1;
    /* Allow the input area to wrap text */
    white-space: pre-wrap;
    word-break: break-word;
    /* Ensure it has a minimum height and consistent line height */
    min-height: 1.2em;
    line-height: 1.2em;
    padding: 0; /* Remove any default padding from the div */
    }

    footer {
      flex-shrink: 0; /* Prevent the footer from shrinking */
      text-align: center;
      padding: 15px 0;
      font-size: 12px;
      opacity: 0.6;
    }

    /* CRT Flicker */
    @keyframes flicker {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.98; }
    60% { opacity: 0.95; }
    70% { opacity: 0.97; }
    80% { opacity: 0.96; }
    90% { opacity: 0.99; }
    }

    /* Scanlines */
    body::before {
    content: '';
    position: absolute;
    top: 0; left: 0;
    width: 100%;
    height: 100%;
    background: repeating-linear-gradient(
      to bottom,
      rgba(0, 255, 0, 0.05),
      rgba(0, 255, 0, 0.05) 2px,
      transparent 2px,
      transparent 4px
    );
    z-index: 1;
    pointer-events: none;
    }

    /* Radial glow for curvature */
    body::after {
    content: '';
    position: absolute;
    top: 0; left: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(circle at center, rgba(0, 255, 0, 0.05), transparent 70%);
    z-index: 0;
    pointer-events: none;
  }

  /* --- GUI Styles --- */
  .gui-hidden {
    display: none;
  }

  .gui-visible {
    /* This class is now just a marker for visibility. */
    /* The .gui-window inside will handle its own positioning and stacking. */
    animation: none; /* Don't flicker the GUI overlay */
  }

  /* --- Fade Out Styles --- */
  .fade-hidden {
    display: none;
  }

  #fade-to-black {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: black;
    z-index: 9999; /* On top of everything */
    opacity: 0;
    transition: opacity 1.5s ease-in;
    pointer-events: none;
  }

  .gui-window {
    position: absolute;
    /* Default centered position for desktop */
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: #00FF00; /* Use background to create the border color */
    border: none;
    box-shadow: 0 0 10px #00FF00;
    width: 420px; /* Set a fixed default width for predictability */
    max-width: 90vw; /* Ensure it shrinks on smaller viewports */
    min-width: 250px;
    min-height: 150px;
    font-family: 'Courier New', Courier, monospace;
    padding: 1px; /* This padding creates a very thin border */
    z-index: 100; /* Base z-index for windows */
    cursor: move;
    display: flex;
    flex-direction: column;
  }

  .gui-title-bar {
    background-color: #00FF00;
    color: black;
    padding: 0 8px;
    font-weight: bold;
    display: flex;
    justify-content: space-between;
    align-items: center;
    line-height: 1; /* Set line height to minimum for compactness */
    cursor: move;
  }

  .resize-handle {
    position: absolute;
    width: 15px;
    height: 15px;
    bottom: 0;
    z-index: 10;
  }
  .resize-handle.se {
    right: 0;
    cursor: se-resize;
  }
  .resize-handle.sw {
    left: 0;
    cursor: sw-resize;
  }
  
  .gui-close-button {
    background: none;
    border: none;
    color: black;
    font-family: monospace;
    font-size: 14px; /* Make the button slightly smaller to reduce title bar height */
    font-weight: bold;
    cursor: pointer;
    padding: 0; /* Remove default button padding */
    line-height: 1; /* Ensure the button itself is compact */
  }

  .gui-content {
    background-color: black; /* Content area has a black background */
    color: #00FF00; /* Text inside is green */
    padding: 0 15px 5px; /* top:0, horizontal:15, bottom:5 */
    flex-grow: 1; /* Allows content to fill available space when resizing */
    overflow: auto; /* Add scrollbar if content overflows */
    cursor: default;
    /* Hide scrollbar for different browsers */
    -ms-overflow-style: none;  /* IE and Edge */
    scrollbar-width: none;  /* Firefox */
  }
  .gui-content::-webkit-scrollbar { display: none; } /* Chrome, Safari, Opera */

  /* Specific styles for the picture viewer content area */
  #pic-content {
    display: flex;
    flex-direction: column;
    padding: 15px; /* Add vertical padding and override horizontal from .gui-content */
  }

  #pic-content img {
    flex-grow: 1; /* Allow the image to fill the available space */
    object-fit: contain; /* Scale the image to fit, preserving aspect ratio */
    /* These are important for flexbox to correctly size/shrink the image */
    min-height: 0;
    width: 100%; /* Ensure it takes up the container's width */
  }
  /* Target the header div specifically to give it a bottom margin, avoiding <p> tag default margin issues. */
  #gui-content > div:first-child,
  #wh-content > div:first-child {
    margin-bottom: 2px;
    line-height: 1;
  }
  .gui-content p { margin: 0 0 2px 0; line-height: 1; } /* Tighter line-height and controlled margin */
  .gui-content ul { list-style: none; padding: 0; margin: 0; }
  .gui-content li { margin-bottom: 2px; line-height: 1; } /* Tighter line-height and a tiny bit of space between items */
  .gui-content a { color: #00FF00; text-decoration: none; cursor: pointer; }
  .gui-content a:hover { background-color: #00FF00; color: black; }

  /*
   * Specific overrides for the main System Menu.
   * This creates a compact list, which visually balances better with the short menu items,
   * making it feel more consistent with the other windows.
  */
  #gui-content li { margin-bottom: 0; } /* Make the list items have no space between them */

  /* --- Mobile Optimizations --- */
  @media (max-width: 768px) {
    .gui-window {
      width: 90vw;
      max-width: none;
      top: 25px;
      left: 50%;
      transform: translateX(-50%);
    }

    .terminal-container {
      padding: 0 1em; /* Reduce horizontal padding for more content space */
    }

    .ascii-art {
      display: none; /* Hide wide ASCII art on small screens as it won't fit */
    }

    body {
      /* Use a slightly larger font on mobile for better readability */
      font-size: clamp(15px, 4vw, 16px);
    }

    .input-line {
      /* Add some space at the very bottom to avoid the on-screen keyboard feeling too cramped */
      padding-bottom: 0.5em;
    }
  }
  </style>
</head>
<body>
  <div class="terminal-container">
    <div class="content-wrapper">
      <div id="terminal"></div>
      <div class="input-line">
        <span>&gt; </span>
        <div id="terminal-input" contenteditable="true"></div>
      </div>
    </div>
    <footer>
     <!-- &copy; 2025 Matthew Emil Iglody-->
    </footer>
  </div>

  <div id="gui-container" class="gui-hidden">
    <div id="gui-window" class="gui-window">
      <div id="gui-title-bar" class="gui-title-bar">
        <span>SYSTEM MENU</span>
        <button id="gui-close-button" class="gui-close-button">X</button>
      </div>
      <div id="gui-content" class="gui-content">
        <div>Select an option to execute the command:</div>
        <ul>
          <li><a href="#" data-command="bio">1. Read Bio</a></li>
          <li><a href="#" data-command="contact">2. View Contact Info</a></li>
          <li><a href="#" data-command="workhistory">3. View Work History</a></li>
        </ul>
      </div>
      <div class="resize-handle se"></div>
      <div class="resize-handle sw"></div>
    </div>
  </div>

  <div id="wh-container" class="gui-hidden">
    <div id="wh-window" class="gui-window">
      <div id="wh-title-bar" class="gui-title-bar">
        <span>Work History</span>
        <button id="wh-close-button" class="gui-close-button">X</button>
      </div>
      <div id="wh-content" class="gui-content">
        <!-- This will be populated by JavaScript -->
      </div>
      <div class="resize-handle se"></div>
      <div class="resize-handle sw"></div>
    </div>
  </div>

  <div id="pic-container" class="gui-hidden">
    <div id="pic-window" class="gui-window">
      <div id="pic-title-bar" class="gui-title-bar">
        <span>Headshot</span>
        <button id="pic-close-button" class="gui-close-button">X</button>
      </div>
      <div id="pic-content" class="gui-content">
        <!--<p>This is a placeholder for an image or other content.</p>-->
        <img src="pics/Matt_Caricature.PNG" alt="Matt_Headshot">
        <!--<p>In the future, this could display an actual image, maybe even a gallery.</p>-->
      </div>
      <div class="resize-handle se"></div>
      <div class="resize-handle sw"></div>
    </div>
  </div>

  <div id="fade-to-black" class="fade-hidden"></div>

  <script>
    const terminal = document.getElementById('terminal');
    const input = document.getElementById('terminal-input');
    const contentWrapper = document.querySelector('.content-wrapper');

    const initialWelcomeHTML = `<div class="centered-line">SECURE SERVER LINK (TM)<br>MATTHEW IGLODY</div>
<div class="centered-line">-----ONE TIME PASSWORD ACCEPTED-----</div>
<pre class="ascii-art">                                                                                                    
    @@@.     @@@     -@@:             @@@                                                           
     @@@    @@@@@    @@@              @@@                                                           
     @@@    @@@@@    @@:    @@@@@@    @@@    @@@@@@.   @@@@@@@    @@@ @@@@@ @@@@@=     @@@@@@       
      @@@  @@@ @@%  @@@   @@@    @@#  @@@   @@@   @@  @@@   @@@@  @@@@. @@@@@  @@@   @@@   .@@:     
      @@@  @@. @@@  @@:   @@@@@@@@@@  @@@  @@@       @@@     @@@  @@@    @@@    @@#  @@@@@@@@@@     
       @@@@@@  .@@=@@@    @@@         @@@  @@@       @@@     @@@  @@@    @@@    @@#  @@@            
       @@@@@-   @@@@@:    @@@.        @@@   @@@   *@ =@@@   @@@#  @@@    @@@    @@#  @@@            
        @@@@    .@@@@      #@@@@@@@   @@@    @@@@@@+   @@@@@@@    @@@    @@@    @@#   @@@@@@@@      
</pre>

> ACCESSING PROFESSIONAL PORTFOLIO...

> INTERFACE PRIVILEGES: READ

> WELCOME USER
`;

    // --- Global State & Element Refs ---
    const guiContainer = document.getElementById('gui-container');
    const guiWindow = document.getElementById('gui-window');
    const guiCloseButton = document.getElementById('gui-close-button');
    const guiContent = document.getElementById('gui-content');
    const picContainer = document.getElementById('pic-container');
    const picWindow = document.getElementById('pic-window');
    const picCloseButton = document.getElementById('pic-close-button');
    const whContainer = document.getElementById('wh-container');
    const whWindow = document.getElementById('wh-window');
    const whCloseButton = document.getElementById('wh-close-button');
    const whContent = document.getElementById('wh-content');
    const fadeOverlay = document.getElementById('fade-to-black');
    let activeTypingInterval = null; // To manage the typewriter effect
    let awaitingResponseFor = null; // State for multi-step commands
    const commandHistory = [];
    let highestZ = 100; // For window stacking

    // Focus the input when the user clicks/taps anywhere on the terminal body
    document.body.addEventListener('click', (event) => {
      // If the user clicks on something that is not the input itself, focus the input.
      // This is to avoid interfering with text selection inside the input field.
      if (event.target !== input) {
        input.focus();
      }
    });

    // Global keydown listener for system-wide shortcuts
    document.addEventListener('keydown', function(event) {
      // Handle Ctrl+C for process cancellation
      if (event.ctrlKey && event.key.toLowerCase() === 'c') {
        // We only want to act if a process is running to avoid interfering with browser's native copy function.
        if (awaitingResponseFor || activeTypingInterval) {
          event.preventDefault();
          
          // Display the interrupt signal. Since the input field might be disabled,
          // we can't rely on its content. We'll just show the signal at the point of interruption.
          appendTextToTerminal('^C');
          
          cancelCurrentProcess();
        }
      }
      // Handle Escape key to close GUI windows
      else if (event.key === 'Escape' || event.key === 'Esc') {
        const isGuiVisible = guiContainer.classList.contains('gui-visible');
        const isPicVisible = picContainer.classList.contains('gui-visible');
        const isWhVisible = whContainer.classList.contains('gui-visible');

        if (isGuiVisible || isPicVisible || isWhVisible) {
          event.preventDefault(); // Prevent default browser action if any window is open

          // Find the top-most window and close it.
          let topWindow = null;
          let maxZ = -1;

          const windows = [
            { name: 'gui', visible: isGuiVisible, element: guiWindow },
            { name: 'pic', visible: isPicVisible, element: picWindow },
            { name: 'wh', visible: isWhVisible, element: whWindow }
          ];

          windows.forEach(win => {
            if (win.visible) {
              const z = parseInt(win.element.style.zIndex) || 0;
              if (z > maxZ) { maxZ = z; topWindow = win.name; }
            }
          });

          if (topWindow === 'gui') hideGui();
          else if (topWindow === 'pic') hidePicWindow();
          else if (topWindow === 'wh') hideWhWindow();
        }
      }
    });

    const commandAliases = {
      'h': 'help',
      '?': 'help',
      'b': 'bio',
      'c': 'contact',
      'wh': 'workhistory',
      'jobs': 'workhistory',
      'exp': 'workhistory',
      'li': 'linkedin',
      'm': 'menu',
      'p': 'pic',
      'cv': 'transfer',
      'resume': 'transfer',
      'history': 'logs',
      'l': 'logs',
      'cls': 'clear',
      'q': 'exit',
      'quit': 'exit',
      'stop': 'cancel'
    };

    const commandDescriptions = {
      'help': 'List available commands',
      'bio': 'Display professional bio',
      'contact': 'Display contact information',
      'workhistory': 'Display professional work history',
      'linkedin': 'Open LinkedIn profile in a new tab',
      'menu': 'Window with clickable menu',
      'pic': 'Launch image viewer',
      'transfer': 'Open CV in a new tab',
      'logs': 'Shows command history with timestamps',
      'clear': 'Clears the terminal and resets to welcome screen',
      'exit': 'End the terminal interface',
      'cancel': 'Cancel current running process or command (or use Ctrl+C)'
    };

    const workHistoryDetails = {
      '1': {
        title: '2014-2016 | Desktop Support Technician | Good Samaritan Regional Medical Center, Suffern, NY',
        description: 'Placeholder text for your first role. Describe your responsibilities and achievements here.'
      },
      '2': {
        title: '2016-2019 | Solutions Analyst II - Radiology IT | NYU Langone Health, New York, NY',
        description: 'Placeholder text for your second role. Describe your responsibilities and achievements here.'
      },
      '3': {
        title: '2019-2022 | Senior Analyst I - Radiology IT | NYU Lanogne Health, New York, NY',
        description: 'Placeholder text for your third role. Describe your responsibilities and achievements here.'
      },
      '4': {
        title: '2022-2024 | Senior Analyst - Research IT | NYU Grossman School of Medicine, New York, NY',
        description: 'Placeholder text for your fourth role. Describe your responsibilities and achievements here.'
      }
    };

    const bioTextPart1 = "Welcome to my professional digital footprint. I'm glad you could take the time to stop by and check it out. My name is Matthew Iglody and I am a mid-career professional who has been working in IT since College. The summer after my freshman year I began interning at Stryker orthopaedics and after graduating college I got my first job working in hospital IT near the town I grew up in.";
    const bioTextPart2 = "[Placeholder for the rest of the bio text. You can fill this in later with more details about your career progression and skills.]";

    function printWelcomeMessage() {
      terminal.innerHTML = initialWelcomeHTML; // Set the initial static content
      const isMobile = window.innerWidth <= 768; // Match the CSS breakpoint
      if (!isMobile) {
        const helpText = commands.help(); // Generate the help text
        // Append the help text just like a command output for consistency
        appendTextToTerminal(`\n${helpText}\n`);
      } else {
        // On mobile, just show a simple prompt to save space.
        appendTextToTerminal(`\nType 'help' for a list of commands.\n`);
      }
    }

    function bringToFront(element) {
      highestZ++;
      element.style.zIndex = highestZ;
    }

    function appendTextToTerminal(text) {
      // Appending a text node is safer than innerHTML and respects the `white-space: pre-wrap` style.
      terminal.appendChild(document.createTextNode(text));
    }

    function showGui() {
      bringToFront(guiWindow);

      // By clearing inline styles, the window reverts to its CSS-defined
      // position, which respects the media query for mobile/desktop.
      guiWindow.style.top = '';
      guiWindow.style.left = '';
      guiWindow.style.transform = '';

      guiContainer.classList.remove('gui-hidden');
      guiContainer.classList.add('gui-visible');
    }

    function hideGui() {
      guiContainer.classList.add('gui-hidden');
      guiContainer.classList.remove('gui-visible');
      input.focus();
    }

    function showPicWindow() {
      bringToFront(picWindow);

      // By clearing inline styles, the window reverts to its CSS-defined
      // position, which respects the media query for mobile/desktop.
      picWindow.style.top = '';
      picWindow.style.left = '';
      picWindow.style.transform = '';

      picContainer.classList.remove('gui-hidden');
      picContainer.classList.add('gui-visible');
    }

    function hidePicWindow() {
      picContainer.classList.add('gui-hidden');
      picContainer.classList.remove('gui-visible');
      input.focus();
    }

    function showWhWindow() {
      bringToFront(whWindow);
      populateWhList(); // Populate with the list of jobs

      // Reset window position
      whWindow.style.top = '';
      whWindow.style.left = '';
      whWindow.style.transform = '';

      whContainer.classList.remove('gui-hidden');
      whContainer.classList.add('gui-visible');
    }

    function hideWhWindow() {
      whContainer.classList.add('gui-hidden');
      whContainer.classList.remove('gui-visible');
      input.focus();
    }

    function populateWhList() {
      let content = '<div>Select a position to view details:</div><ul>';
      Object.entries(workHistoryDetails).forEach(([key, value]) => {
        content += `<li><a href="#" data-job-id="${key}">${value.title}</a></li>`;
      });
      content += '</ul>';
      whContent.innerHTML = content;
    }

    function populateWhDetail(jobId) {
      const job = workHistoryDetails[jobId];
      if (!job) return;
      let content = `<p><strong>${job.title}</strong></p><p style="white-space: normal; margin-top: 1em;">${job.description}</p><br><p><a href="#" data-job-id="back">-- Back to List --</a></p>`;
      whContent.innerHTML = content;
    }
    
    function simulateCommand(command) {
      appendTextToTerminal(`\n> ${command}\n`);
      commandHistory.push({ text: command, timestamp: new Date() });
      historyIndex = commandHistory.length;
      handleCommand(command);
      contentWrapper.scrollTop = contentWrapper.scrollHeight;
    }

    function typewriterEffect(text, onComplete) {
      if (activeTypingInterval) {
        clearInterval(activeTypingInterval);
      }
      let i = 0;
      input.contentEditable = 'false'; // Disable input while typing

      // Create a dedicated container for the typewriter text. This prevents
      // re-rendering the entire terminal on each character and is more performant.
      const typewriterContainer = document.createElement('span');
      terminal.appendChild(typewriterContainer);

      activeTypingInterval = setInterval(() => {
        if (i < text.length) {
          typewriterContainer.textContent += text.charAt(i);
          i++;
          contentWrapper.scrollTop = contentWrapper.scrollHeight;
        } else {
          clearInterval(activeTypingInterval);
          activeTypingInterval = null; // Reset the handle
          if (onComplete) onComplete();
        }
      }, 30); // Adjust typing speed here (in milliseconds)
    }

    function cancelCurrentProcess() {
      if (!awaitingResponseFor && !activeTypingInterval) {
        return false; // Nothing to cancel
      }

      if (activeTypingInterval) {
        clearInterval(activeTypingInterval);
        activeTypingInterval = null;
      }
      awaitingResponseFor = null;

      appendTextToTerminal(`\n\n[PROCESS CANCELLED]\nReturning to main prompt.\n`);
      input.contentEditable = 'true';
      input.focus();
      return true;
    }

    function moveCursorToEnd(element) {
      const range = document.createRange();
      const selection = window.getSelection();
      range.selectNodeContents(element);
      range.collapse(false); // false collapses to the end
      selection.removeAllRanges();
      selection.addRange(range);
      element.focus();
    }

    function downloadTranscript() {
      // We grab the innerText of the terminal, but add a final message.
      const transcriptContent = terminal.innerText + "\n\n--- TRANSCRIPT END ---";
      const blob = new Blob([transcriptContent], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      link.download = `terminal-session-${timestamp}.txt`;
      link.href = url;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      appendTextToTerminal(`\nDownloading transcript...`);
    }

    function makeDraggable(element, handle) {
      let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;

      const dragMouseDown = (e) => {
        // Prevent dragging when clicking on interactive elements (content, close button, resize handle)
        // Using classes makes this function reusable for any window.
        if (e.target.closest('.gui-content') || e.target.closest('.gui-close-button') || e.target.closest('.resize-handle')) {
          return;
        }
        // If the element is centered with transform, convert to absolute pixel positioning for dragging
        if (element.style.transform) {
          const rect = element.getBoundingClientRect();
          element.style.transform = 'none';
          element.style.left = `${rect.left}px`;
          element.style.top = `${rect.top}px`;
        }

        e.preventDefault();
        // Get the initial cursor position
        if (e.type === 'touchstart') {
          pos3 = e.touches[0].clientX;
          pos4 = e.touches[0].clientY;
        } else {
          pos3 = e.clientX;
          pos4 = e.clientY;
        }
        document.addEventListener('mouseup', closeDragElement);
        document.addEventListener('touchend', closeDragElement);
        document.addEventListener('mousemove', elementDrag);
        document.addEventListener('touchmove', elementDrag);
      };

      const elementDrag = (e) => {
        e.preventDefault();
        const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
        const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
        pos1 = pos3 - clientX;
        pos2 = pos4 - clientY;
        pos3 = clientX;
        pos4 = clientY;
        element.style.top = (element.offsetTop - pos2) + "px";
        element.style.left = (element.offsetLeft - pos1) + "px";
      };

      const closeDragElement = () => {
        document.removeEventListener('mouseup', closeDragElement);
        document.removeEventListener('touchend', closeDragElement);
        document.removeEventListener('mousemove', elementDrag);
        document.removeEventListener('touchmove', elementDrag);
      };

      handle.addEventListener('mousedown', dragMouseDown);
      handle.addEventListener('touchstart', dragMouseDown);
    }

    function makeResizable(element) {
      let initialX, initialY, initialWidth, initialHeight, initialLeft;
      let direction = '';

      const resizeMouseDown = (e) => {
        e.preventDefault();
        e.stopPropagation(); // Prevent triggering the drag behavior on the parent

        // If the element is centered with transform, convert to absolute pixel positioning.
        // This ensures 'offsetLeft' is reliable for calculations.
        if (element.style.transform) {
          const rect = element.getBoundingClientRect();
          element.style.transform = 'none';
          element.style.left = `${rect.left}px`;
          element.style.top = `${rect.top}px`;
        }

        if (e.target.classList.contains('se')) {
          direction = 'se';
        } else if (e.target.classList.contains('sw')) {
          direction = 'sw';
        } else {
          return;
        }

        initialWidth = element.offsetWidth;
        initialHeight = element.offsetHeight;
        initialLeft = element.offsetLeft;

        if (e.type === 'touchstart') {
          initialX = e.touches[0].clientX;
          initialY = e.touches[0].clientY;
        } else {
          initialX = e.clientX;
          initialY = e.clientY;
        }

        document.addEventListener('mousemove', elementResize, { passive: false });
        document.addEventListener('touchmove', elementResize, { passive: false });
        document.addEventListener('mouseup', stopResize, { once: true });
        document.addEventListener('touchend', stopResize, { once: true });
      };

      const elementResize = (e) => {
        // Prevent page scroll on touch devices
        if (e.type === 'touchmove') {
          e.preventDefault();
        }

        const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
        const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;

        const dx = clientX - initialX;
        const dy = clientY - initialY;

        // Get min dimensions from CSS to make resizing more robust.
        const styles = window.getComputedStyle(element);
        const minWidth = parseInt(styles.minWidth, 10);
        const minHeight = parseInt(styles.minHeight, 10);

        const newHeight = initialHeight + dy;
        if (newHeight >= minHeight) {
          element.style.height = newHeight + 'px';
        }

        if (direction === 'se') {
          const newWidth = initialWidth + dx;
          if (newWidth >= minWidth) {
            element.style.width = newWidth + 'px';
          }
        } else if (direction === 'sw') {
          const newWidth = initialWidth - dx;
          if (newWidth >= minWidth) {
            element.style.width = newWidth + 'px';
            element.style.left = (initialLeft + dx) + 'px';
          }
        }
      };

      const stopResize = () => {
        document.removeEventListener('mousemove', elementResize);
        document.removeEventListener('touchmove', elementResize);
      };

      const handles = element.querySelectorAll('.resize-handle');
      handles.forEach(handle => {
        handle.addEventListener('mousedown', resizeMouseDown);
        handle.addEventListener('touchstart', resizeMouseDown);
      });
    }

    function handleResponse(response) {
      switch (awaitingResponseFor) {
        case 'transcript_prompt':
          if (response === 'y' || response === 'yes') {
            downloadTranscript();
          }
          // After handling the transcript, ask for final confirmation to exit.
          appendTextToTerminal(`\n\nAre you sure you want to terminate the session? (y/n)`);
          awaitingResponseFor = 'final_exit_confirm';
          break;
        case 'final_exit_confirm':
          if (response === 'y' || response === 'yes') {
            awaitingResponseFor = null;
            const exitMessage = `\n\nSESSION TERMINATED.\nGOODBYE.`;
            typewriterEffect(exitMessage, () => {
              // We visually end the session by fading to black. After the fade animation
              // completes, we will attempt to close the window.
              fadeOverlay.style.display = 'block';

              // Add a listener that will close the window once the fade is complete.
              fadeOverlay.addEventListener('transitionend', () => {
                window.close();
              }, { once: true });

              // A short delay ensures the 'display' change is rendered before the opacity transition starts.
              setTimeout(() => {
                fadeOverlay.style.opacity = '1';
              }, 50);
            });
          } else {
            appendTextToTerminal(`\nExit cancelled.\n`);
            awaitingResponseFor = null;
          }
          break;
        case 'bio_continue':
          if (response === 'y' || response === 'yes') {
            awaitingResponseFor = null; // Reset state before async operation
            typewriterEffect(`\n${bioTextPart2}`, () => {
              appendTextToTerminal("\n");
              input.contentEditable = 'true';
              input.focus();
            });
          } else {
            appendTextToTerminal(`\nReturning to main prompt.\n`);
            awaitingResponseFor = null;
          }
          break;
      }
    }

    let historyIndex = 0;

    input.addEventListener('keydown', function(event) {
      // Use innerText for contenteditable div
      const rawInput = input.innerText;
      const currentInput = rawInput.trim();
      const currentInputLower = currentInput.toLowerCase();

      // Handle up/down arrow for command history
      if (event.key === 'ArrowUp') {
        event.preventDefault();
        if (historyIndex > 0) {
          historyIndex--;
          input.innerText = commandHistory[historyIndex].text;
          // Move cursor to the end of the input for a better user experience
          setTimeout(() => moveCursorToEnd(input), 0);
        }
      } else if (event.key === 'ArrowDown') {
        event.preventDefault();
        if (historyIndex < commandHistory.length - 1) {
          historyIndex++;
          input.innerText = commandHistory[historyIndex].text;
          setTimeout(() => moveCursorToEnd(input), 0);
        } else {
          // If we are at the end of history, going down again clears the input for a new command
          historyIndex = commandHistory.length;
          input.innerText = '';
        }
      }
      // Handle Tab for command completion
      else if (event.key === 'Tab') {
        event.preventDefault();
        if (currentInputLower === '') return;

        const allPossibleCommands = [...Object.keys(commands), ...Object.keys(commandAliases)];
        const matches = allPossibleCommands.filter(c => c.startsWith(currentInputLower));

        if (matches.length === 1) {
          input.innerText = matches[0];
          setTimeout(() => moveCursorToEnd(input), 0);
        } else if (matches.length > 1) {
          // Find the longest common prefix among all matches
          let sortedMatches = [...matches].sort();
          let first = sortedMatches[0];
          let last = sortedMatches[sortedMatches.length - 1];
          let i = 0;
          while (i < first.length && first.charAt(i) === last.charAt(i)) {
            i++;
          }
          const commonPrefix = first.substring(0, i);
          if (commonPrefix.length > currentInput.length) {
            input.innerText = commonPrefix;
            setTimeout(() => moveCursorToEnd(input), 0);
          }
        }
      }
      // Handle Enter to submit command
      else if (event.key === 'Enter') {
        event.preventDefault(); // Prevent adding a new line in the contenteditable div
        // On the first command, re-enable scrolling for the content area.
        contentWrapper.classList.remove('no-scroll-on-launch');

        if (currentInput === '') return;

        appendTextToTerminal(`\n> ${currentInput}`); // Display original casing

        const resolvedForCancel = commandAliases[currentInputLower] || currentInputLower;

        // --- Special 'cancel' command to interrupt processes ---
        if (resolvedForCancel === 'cancel') {
          if (!cancelCurrentProcess()) { // The typed command doesn't show ^C
            appendTextToTerminal(`\nNo active process to cancel.\n`);
          }
        } else if (awaitingResponseFor) {
          appendTextToTerminal(`\n`);
          handleResponse(currentInputLower);
        } else {
          appendTextToTerminal(`\n`);
          commandHistory.push({ text: currentInput, timestamp: new Date() });
          historyIndex = commandHistory.length; // Reset history index
          handleCommand(currentInputLower);
        }

        input.innerText = '';
        contentWrapper.scrollTop = contentWrapper.scrollHeight;
      }
    });

    // --- GUI Event Listeners ---
    // We add listeners for both 'click' and 'touchend' to ensure the GUI is
    // responsive on touch devices while maintaining compatibility with mouse input.
    // Calling preventDefault() in the handler for 'touchend' stops the browser
    // from firing a redundant 'click' event after a tap.
    const handleCloseClick = (event) => {
      event.preventDefault();
      hideGui();
    };
    guiCloseButton.addEventListener('click', handleCloseClick);
    guiCloseButton.addEventListener('touchend', handleCloseClick);

    const handlePicCloseClick = (event) => {
      event.preventDefault();
      hidePicWindow();
    };
    picCloseButton.addEventListener('click', handlePicCloseClick);
    picCloseButton.addEventListener('touchend', handlePicCloseClick);

    const handleWhCloseClick = (event) => {
      event.preventDefault();
      hideWhWindow();
    };
    whCloseButton.addEventListener('click', handleWhCloseClick);
    whCloseButton.addEventListener('touchend', handleWhCloseClick);

    const handleMenuClick = (event) => {
      const target = event.target.closest('a');
      if (target && target.dataset.command) {
        event.preventDefault();
        const command = target.dataset.command;
        simulateCommand(command);
        hideGui(); // Close the window after selection
      }
    };
    guiContent.addEventListener('click', handleMenuClick);
    guiContent.addEventListener('touchend', handleMenuClick);

    const handleWhClick = (event) => {
      const target = event.target.closest('a');
      if (target && target.dataset.jobId) {
        event.preventDefault();
        const jobId = target.dataset.jobId;
        if (jobId === 'back') {
          populateWhList();
        } else {
          populateWhDetail(jobId);
        }
      }
    };
    whContent.addEventListener('click', handleWhClick);
    whContent.addEventListener('touchend', handleWhClick);

    makeDraggable(document.getElementById('gui-window'), document.getElementById('gui-title-bar'));
    makeResizable(document.getElementById('gui-window'), document.getElementById('gui-resize-handle'));

    makeDraggable(document.getElementById('pic-window'), document.getElementById('pic-title-bar'));
    makeResizable(document.getElementById('pic-window'), document.getElementById('pic-resize-handle'));

    makeDraggable(document.getElementById('wh-window'), document.getElementById('wh-title-bar'));
    makeResizable(document.getElementById('wh-window'), document.getElementById('wh-resize-handle'));

    guiWindow.addEventListener('mousedown', () => bringToFront(guiWindow));
    picWindow.addEventListener('mousedown', () => bringToFront(picWindow));

    const commands = {
      help: () => {
        const isMobile = window.innerWidth <= 768; // Match the CSS breakpoint

        const commandToAliases = Object.entries(commandAliases).reduce((acc, [alias, command]) => {
          (acc[command] = acc[command] || []).push(alias);
          return acc;
        }, {});

        let helpText = 'AVAILABLE COMMANDS:\n\n';

        if (isMobile) {
          // Mobile-friendly stacked view for better readability
          const labelWidth = 10;
          Object.entries(commandDescriptions).forEach(([command, description]) => {
            const aliases = (commandToAliases[command] || []).join(', ');
            helpText += `${'COMMAND:'.padEnd(labelWidth)}${command}\n`;
            if (aliases) {
              helpText += `${'ALIASES:'.padEnd(labelWidth)}${aliases}\n`;
            }
            helpText += `${'DESC:'.padEnd(labelWidth)}${description}\n\n`;
          });
        } else {
          // Desktop table view
          const commandColWidth = 12;
          const aliasesColWidth = 15;

          helpText += 'COMMAND'.padEnd(commandColWidth) + 'ALIASES'.padEnd(aliasesColWidth) + 'DESCRIPTION\n';
          helpText += '-------'.padEnd(commandColWidth) + '-------'.padEnd(aliasesColWidth) + '-----------\n';

          Object.entries(commandDescriptions).forEach(([command, description]) => {
            const aliases = (commandToAliases[command] || []).join(', ');
            helpText += `${command.padEnd(commandColWidth)}${aliases.padEnd(aliasesColWidth)}${description}\n`;
          });
        }
        return helpText.trim();
      },
      bio: () => {
        typewriterEffect(bioTextPart1, () => {
          // This function runs after the typing is complete
          appendTextToTerminal(`\n\nWould you like to continue reading? (y/n)`);
          awaitingResponseFor = 'bio_continue';
          input.contentEditable = 'true'; // Re-enable the input field
          input.focus(); // Focus on the input field for the next command
          contentWrapper.scrollTop = contentWrapper.scrollHeight;
        });
        return null; // Signal that output is handled asynchronously
      },
      contact: () => {
        const contactText = "Cell: 732-573-8567\nEmail: mattiglody@gmail.com";
        typewriterEffect(contactText, () => {
          // This function runs after the typing is complete
          appendTextToTerminal("\n"); // Add spacing after the contact info
          input.contentEditable = 'true'; // Re-enable the input field
          input.focus(); // Focus on the input field for the next command
          contentWrapper.scrollTop = contentWrapper.scrollHeight;
        });
        return null; // Signal that output is handled asynchronously
      },
      workhistory: () => {
        showWhWindow();
        return "Launching Work History viewer...";
      },
      linkedin: () => {
        const url = 'https://www.linkedin.com/in/matthew-iglody/';
        window.open(url, '_blank');
        return "ACCESSING EXTERNAL LINK...\nREDIRECTING TO LINKEDIN PROFILE IN NEW TAB.";
      },
      menu: () => {
        showGui();
        return null; // GUI handles its own display, no text output needed
      },
      pic: () => {
        showPicWindow();
        return "Launching image viewer...";
      },
      transfer: () => {
        const filePath = 'docs/Matthew_E_Iglody_2025_CV.pdf';
        // Open the file in a new tab. The browser's built-in PDF viewer will handle it.
        window.open(filePath, '_blank');
        return "ACCESSING DOCUMENT...\nOPENING CV IN NEW TAB.";
      },
      logs: () => {
        // Exclude the 'logs' command itself from the output for a cleaner history view.
        if (commandHistory.length <= 1) {
          return "No previous commands in history.";
        }
        return commandHistory.slice(0, -1).map(entry => {
          const time = entry.timestamp.toLocaleTimeString('en-US', { hour12: false });
          return `[${time}] ${entry.text}`;
        }).join("\n");
      },
      exit: () => {
        awaitingResponseFor = 'transcript_prompt';
        return "Would you like a transcript of your activity? (y/n)";
      },
    };

    function handleCommand(cmd) {
      const resolvedCmd = commandAliases[cmd] || cmd;

      // The 'clear' command is special as it modifies the terminal directly
      if (resolvedCmd === 'clear') {
        printWelcomeMessage();
        return;
      }

      const commandFn = commands[resolvedCmd];
      if (!commandFn) {
        appendTextToTerminal(`Unrecognized command: '${cmd}'\nType 'help' (or 'h') for options.\n`);
        return;
      }

      const output = commandFn();

      // If a command returns null, it handles its own output (e.g., typewriter)
      if (output === null) return;

      // Add a single newline for consistent spacing before the next prompt.
      appendTextToTerminal(output + "\n");
    }

    // --- INITIALIZATION ---
    printWelcomeMessage();
    contentWrapper.classList.add('no-scroll-on-launch');
    whWindow.addEventListener('mousedown', () => bringToFront(whWindow));
  </script>
</body>
</html>
