<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Secure Server</title>
  <!--
    A more robust favicon setup for maximum compatibility.
    The browser will pick the best one for its context (tab, bookmarks, etc.).
  -->
  <link rel="icon" href="favicon.svg" type="image/svg+xml"> <!-- Modern, high-quality SVG -->
  <link rel="apple-touch-icon" href="apple-touch-icon.png"> <!-- iOS home screen icon (180x180) -->
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
  <link rel="shortcut icon" href="favicon.ico"> <!-- Fallback for older browsers -->
  <meta name="theme-color" content="#000000">
  <style>
    html {
      height: 100%;
      overflow: hidden; /* Prevent root-level scrollbars */
    }
    body {
    background-color: black;
    color: #00FF00;
    font-family: 'Courier New', Courier, monospace;
    font-size: clamp(14px, 2.5vw, 15px); /* Slightly smaller max font-size for a more 'zoomed-out' feel */
    margin: 0;
    white-space: pre-wrap;
    /* The body itself should fill the html container */
    height: 100%;
    overflow: hidden; /* Prevent the main page from ever scrolling */
    animation: flicker 0.2s infinite;
    }

    .terminal-container {
      max-width: 900px;
      /* Add horizontal padding to indent the content from the edges */
      padding: 0 2em; /* Horizontal padding for centering */
      box-sizing: border-box;
      margin: auto;
      /* Use flexbox to create a sticky footer layout */
      display: flex;
      flex-direction: column;
      height: 100%; /* Fill the body's height */
    }

    .ascii-art {
      /* Use clamp() to create a responsive font-size with min/max values */
      font-size: clamp(4px, 1.4vw, 13px);
      text-align: center;
      line-height: 1.1; /* Keep lines tight */
      white-space: pre; /* Preserve whitespace and prevent wrapping */
      overflow: hidden; /* Hide any minor overflow */
      padding: 10px 0;
      /* The filter from the parent #terminal is a bit strong for small text, so we reduce it */
      filter: drop-shadow(0 0 2px #00FF00);
    }

    .content-wrapper {
      flex-grow: 1; /* Allow this area to grow and push the footer down */
      overflow-y: auto; /* This makes the wrapper scrollable */
      min-height: 0; /* Fix for flexbox items with overflowing content */
      box-sizing: border-box;
      padding-top: 0; /* Removed padding to move content higher */
      /* Hide scrollbar for different browsers */
      -ms-overflow-style: none;  /* IE and Edge */
      scrollbar-width: none;  /* Firefox */
    }
    .content-wrapper::-webkit-scrollbar {
      display: none; /* Chrome, Safari, Opera */
    }

    .content-wrapper.no-scroll-on-launch {
      overflow-y: hidden;
    }

    #terminal {
    position: relative;
    z-index: 2;
    filter: drop-shadow(0 0 4px #00FF00);
    white-space: pre-wrap; /* Ensure newlines in text are respected */
    }

    .centered-line {
      text-align: center;
    }

    .input-line {
    display: flex;
    /* Use margin to create a consistent space above the input line */
    /* Set margin to one line-height to create a full blank line of space */
    margin-top: 1.2em;
    }

    .input-line span {
    flex-shrink: 0;
    }

    #terminal-input {
    background: black;
    border: none;
    color: #00FF00;
    font-family: inherit;
    font-size: inherit;
    outline: none;
    flex-grow: 1;
    /* Allow the input area to wrap text */
    white-space: pre-wrap;
    word-break: break-word;
    /* Ensure it has a minimum height and consistent line height */
    min-height: 1.2em;
    line-height: 1.2em;
    padding: 0; /* Remove any default padding from the div */
    }

    footer {
      flex-shrink: 0; /* Prevent the footer from shrinking */
      text-align: center;
      padding: 15px 0;
      font-size: 12px;
      opacity: 0.6;
    }

    /* CRT Flicker */
    @keyframes flicker {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.98; }
    60% { opacity: 0.95; }
    70% { opacity: 0.97; }
    80% { opacity: 0.96; }
    90% { opacity: 0.99; }
    }

    /* Scanlines */
    body::before {
    content: '';
    position: absolute;
    top: 0; left: 0;
    width: 100%;
    height: 100%;
    background: repeating-linear-gradient(
      to bottom,
      rgba(0, 255, 0, 0.05),
      rgba(0, 255, 0, 0.05) 2px,
      transparent 2px,
      transparent 4px
    );
    z-index: 1;
    pointer-events: none;
    }

    /* Radial glow for curvature */
    body::after {
    content: '';
    position: absolute;
    top: 0; left: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(circle at center, rgba(0, 255, 0, 0.05), transparent 70%);
    z-index: 0;
    pointer-events: none;
  }

  /* --- GUI Styles --- */
  .gui-hidden {
    display: none;
  }

  .gui-visible {
    /* This class is now just a marker for visibility. */
    /* The .gui-window inside will handle its own positioning and stacking. */
    animation: none; /* Don't flicker the GUI overlay */
  }

  /* --- Fade Out Styles --- */
  .fade-hidden {
    display: none;
  }

  #fade-to-black {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: black;
    z-index: 9999; /* On top of everything */
    opacity: 0;
    transition: opacity 1.5s ease-in;
    pointer-events: none;
  }

  .gui-window {
    position: absolute;
    /* Default centered position for desktop */
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: #00FF00; /* Use background to create the border color */
    border: none;
    box-shadow: 0 0 10px #00FF00;
    width: 420px; /* Set a fixed default width for predictability */
    max-width: 90vw; /* Ensure it shrinks on smaller viewports */
    min-width: 250px;
    min-height: 150px;
    font-family: 'Courier New', Courier, monospace;
    padding: 1px; /* This padding creates a very thin border */
    z-index: 100; /* Base z-index for windows */
    cursor: move;
    display: flex;
    flex-direction: column;
  }

  /* Specific override for the picture window to be smaller and positioned top-left */
  #pic-window {
    width: 250px;
    height: auto; /* Let content determine height */
    top: 25px; /* Position from the top */
    left: 25px; /* Position from the left */
    transform: none; /* Override the default centering transform */
  }

  /* Specific override for the bio window to be positioned top-right */
  #bio-window {
    width: 450px;
    height: 400px;
    top: 25px; /* Position from the top */
    right: 25px; /* Position from the right */
    left: auto; /* Override the default left: 50% */
    transform: none; /* Override the default centering transform */
  }

  #bio-content {
    white-space: pre-wrap; /* Ensure newlines in bio text are respected */
  }
  /* Style for the inline input in the bio window to remove the focus outline */
  #bio-content span[contenteditable="true"] {
    outline: none;
    display: inline-block; /* Ensures it behaves predictably */
  }

  .gui-title-bar {
    background-color: #00FF00;
    color: black;
    padding: 0 8px;
    font-weight: bold;
    display: flex;
    justify-content: space-between;
    align-items: center;
    line-height: 1; /* Set line height to minimum for compactness */
    cursor: move;
  }

  .resize-handle {
    position: absolute;
    width: 15px;
    height: 15px;
    bottom: 0;
    z-index: 10;
  }
  .resize-handle.se {
    right: 0;
    cursor: se-resize;
  }
  .resize-handle.sw {
    left: 0;
    cursor: sw-resize;
  }
  
  .gui-close-button {
    background: none;
    border: none;
    color: black;
    font-family: monospace;
    font-size: 14px; /* Make the button slightly smaller to reduce title bar height */
    font-weight: bold;
    cursor: pointer;
    padding: 0; /* Remove default button padding */
    line-height: 1; /* Ensure the button itself is compact */
  }

  .gui-content {
    background-color: black; /* Content area has a black background */
    color: #00FF00; /* Text inside is green */
    font-size: 13px; /* Standardize font size in all GUI windows for a tighter feel */
    padding: 0 15px 5px; /* top:0, horizontal:15, bottom:5 */
    flex-grow: 1; /* Allows content to fill available space when resizing */
    overflow: auto; /* Add scrollbar if content overflows */
    cursor: default;
    /* --- Custom Scrollbar Styles (when needed) --- */
    scrollbar-width: thin; /* For Firefox */
    scrollbar-color: #00FF00 black; /* thumb color track color - For Firefox */
  }
  /* For Webkit browsers (Chrome, Safari, Edge) */
  .gui-content::-webkit-scrollbar {
    width: 8px; /* Width of the scrollbar */
  }
  .gui-content::-webkit-scrollbar-track {
    background: black; /* Color of the tracking area */
  }
  .gui-content::-webkit-scrollbar-thumb {
    background-color: #00FF00; /* Color of the scroll thumb */
    border: 2px solid black; /* Creates padding around thumb */
  }

  /* Specific styles for the picture viewer content area */
  #pic-content {
    display: flex;
    flex-direction: column;
    padding: 15px; /* Add vertical padding and override horizontal from .gui-content */
  }

  #pic-content img {
    flex-grow: 1; /* Allow the image to fill the available space */
    object-fit: contain; /* Scale the image to fit, preserving aspect ratio */
    /* These are important for flexbox to correctly size/shrink the image */
    min-height: 0;
    width: 100%; /* Ensure it takes up the container's width */
  }
  /* Target the header div specifically to give it a bottom margin, avoiding <p> tag default margin issues. */
  #gui-content > div:first-child {
    margin-bottom: 2px;
    line-height: 1;
  }
  .gui-content p { margin: 0 0 2px 0; line-height: 1; } /* Tighter line-height and controlled margin */
  .gui-content ul { list-style: none; padding: 0; margin: 0; }
  .gui-content a { color: #00FF00; text-decoration: none; cursor: pointer; }
  .gui-content a:hover { background-color: #00FF00; color: black; }

  .gui-footer {
    background-color: black;
    color: #00FF00;
    padding: 2px 8px;
    font-size: 12px;
    text-align: center;
    flex-shrink: 0; /* Prevent it from shrinking */
    border-top: 1px solid #00FF00; /* Separator line */
    min-height: 1.2em; /* Ensure it has some height */
    line-height: 1.2em;
  }

  /* --- Mobile Optimizations --- */
  @media (max-width: 768px) {
    .gui-window {
      width: 90vw;
      max-width: none;
      top: 25px;
      left: 50%;
      transform: translateX(-50%);
    }

    /* Make the bio window shorter on mobile to prevent it from taking up too much screen space. */
    #bio-window {
      /* Match the picture window's dimensions on mobile */
      width: 90vw;
      height: auto;
      /* Reset the 'right' property so it can be centered correctly by the generic .gui-window rule */
      right: auto;
      /* Explicitly apply the centering rules to override the desktop-specific positioning */
      left: 50%;
      transform: translateX(-50%);
    }

    .terminal-container {
      padding: 0 1em; /* Reduce horizontal padding for more content space */
    }

    .ascii-art {
      display: none; /* Hide wide ASCII art on small screens as it won't fit */
    }

    body {
      /* Use a slightly larger font on mobile for better readability */
      font-size: clamp(15px, 4vw, 16px);
    }

    .input-line {
      /* Add some space at the very bottom to avoid the on-screen keyboard feeling too cramped */
      padding-bottom: 0.5em;
    }
  }
  </style>
</head>
<body>
  <div class="terminal-container">
    <div class="content-wrapper">
      <div id="terminal"></div>
      <div class="input-line">
        <span>&gt; </span>
        <div id="terminal-input" contenteditable="true"></div>
      </div>
    </div>
    <footer>
     <!-- &copy; 2025 Matthew Emil Iglody-->
    </footer>
  </div>

  <div id="pic-container" class="gui-hidden">
    <div id="pic-window" class="gui-window">
      <div id="pic-title-bar" class="gui-title-bar">
        <span>Headshot</span>
        <button id="pic-close-button" class="gui-close-button">X</button>
      </div>
      <div id="pic-content" class="gui-content">
        <!--<p>This is a placeholder for an image or other content.</p>-->
        <img src="pics/Matt_Caricature.PNG" alt="Matt_Headshot">
        <!--<p>In the future, this could display an actual image, maybe even a gallery.</p>-->
      </div>
      <div class="resize-handle se"></div>
      <div class="resize-handle sw"></div>
    </div>
  </div>

  <div id="bio-container" class="gui-hidden">
    <div id="bio-window" class="gui-window">
      <div id="bio-title-bar" class="gui-title-bar">
        <span>BIO</span>
        <button id="bio-close-button" class="gui-close-button">X</button>
      </div>
      <div id="bio-content" class="gui-content">
        <!-- Populated by JS -->
      </div>
      <div id="bio-footer" class="gui-footer">
        <!-- Populated by JS -->
      </div>
      <div class="resize-handle se"></div>
      <div class="resize-handle sw"></div>
    </div>
  </div>

  <div id="fade-to-black" class="fade-hidden"></div>

  <script src="script.js"></script>
  <script>
    const terminal = document.getElementById('terminal');
    const input = document.getElementById('terminal-input');
    const contentWrapper = document.querySelector('.content-wrapper');

    // --- Global State & Element Refs ---
    const picContainer = document.getElementById('pic-container');
    const picWindow = document.getElementById('pic-window');
    const picCloseButton = document.getElementById('pic-close-button');
    const bioContainer = document.getElementById('bio-container');
    const bioWindow = document.getElementById('bio-window');
    const bioCloseButton = document.getElementById('bio-close-button');
    const bioContent = document.getElementById('bio-content');
    const bioFooter = document.getElementById('bio-footer');
    const fadeOverlay = document.getElementById('fade-to-black');
    let activeTypingInterval = null; // To manage the typewriter effect
    let bioTypingInterval = null; // To manage the bio window's typewriter
    let awaitingResponseFor = null; // State for multi-step commands
    const commandHistory = [];
    let currentBioPartIndex = 0;
    let bioAwaitingResponse = false;
    let highestZ = 100; // For window stacking
    let windowStack = []; // To manage open window order

    // Focus the input when the user clicks/taps anywhere on the terminal body
    document.body.addEventListener('click', (event) => {
      // If the click is inside a GUI window or on the main input itself, do nothing.
      // This allows interaction with GUI elements without losing focus.
      if (event.target.closest('.gui-window') || event.target === input) {
        return;
      }
      // Otherwise, focus the main terminal input.
      input.focus();
    });

    // Global keydown listener for system-wide shortcuts
    document.addEventListener('keydown', function(event) {
      // Handle Ctrl+C for process cancellation
      if (event.ctrlKey && event.key.toLowerCase() === 'c') {
        // We only want to act if a process is running to avoid interfering with browser's native copy function.
        if (awaitingResponseFor || activeTypingInterval) {
          event.preventDefault();
          
          // Display the interrupt signal. Since the input field might be disabled,
          // we can't rely on its content. We'll just show the signal at the point of interruption.
          appendTextToTerminal('^C');
          
          cancelCurrentProcess();
        }
      }
      // Handle Escape key to close GUI windows
      else if (event.key === 'Escape' || event.key === 'Esc') {
        // If there are any windows in our stack, close the top-most one.
        if (windowStack.length > 0) {
          event.preventDefault(); // Prevent default browser action
          const topWindowId = windowStack[windowStack.length - 1];
          if (topWindowId === 'pic-window') {
            hidePicWindow();
          } else if (topWindowId === 'bio-window') {
            hideBioWindow();
          }
        }
      }
    });

    // Centralized handler to bring a window to the front when clicked.
    document.addEventListener('mousedown', (event) => {
      const clickedWindow = event.target.closest('.gui-window');
      if (clickedWindow) {
        bringToFront(clickedWindow);
      }
    });

    function printWelcomeMessage() {
      terminal.innerHTML = initialWelcomeHTML; // Set the initial static content
      const isMobile = window.innerWidth <= 768; // Match the CSS breakpoint
      if (!isMobile) {
        const helpText = commands.help(); // Generate the help text
        // Append the help text just like a command output for consistency
        appendTextToTerminal(`\n${helpText}\n`);
      } else {
        // On mobile, just show a simple prompt to save space.
        appendTextToTerminal(`\nType 'help' for a list of commands.\n`);
      }
    }

    function bringToFront(element) {
      highestZ++;
      element.style.zIndex = highestZ;

      // Manage the window stack to track the top-most window
      const windowId = element.id;
      // Remove from stack if it exists to avoid duplicates
      const index = windowStack.indexOf(windowId);
      if (index > -1) {
        windowStack.splice(index, 1);
      }
      // Add to the end of the array (the "top" of the stack)
      windowStack.push(windowId);
    }

    function appendTextToTerminal(text) {
      // Appending a text node is safer than innerHTML and respects the `white-space: pre-wrap` style.
      terminal.appendChild(document.createTextNode(text));
    }

    function showPicWindow() {
      bringToFront(picWindow);

      // By clearing inline styles, the window reverts to its CSS-defined
      // position, which respects the media query for mobile/desktop.
      picWindow.style.top = '';
      picWindow.style.left = '';
      picWindow.style.transform = '';

      picContainer.classList.remove('gui-hidden');
      picContainer.classList.add('gui-visible');
    }

    function hidePicWindow() {
      picContainer.classList.add('gui-hidden');
      picContainer.classList.remove('gui-visible');

      // Remove this window from the stack
      const index = windowStack.indexOf('pic-window');
      if (index > -1) {
        windowStack.splice(index, 1);
      }

      input.focus();
    }

    function showBioWindow() {
      bringToFront(bioWindow);

      // If bio has never been started, initialize it.
      if (bioContent.innerHTML.trim() === '') {
        currentBioPartIndex = 0;
        bioAwaitingResponse = false;
        bioFooter.innerHTML = '';
        typeNextBioPart();
      } else if (!bioTypingInterval && !bioAwaitingResponse && currentBioPartIndex < bioParts.length) {
        // If it's not currently typing or waiting, but there's more to type, resume.
        typeNextBioPart();
      }

      // Reset window position
      bioWindow.style.top = '';
      bioWindow.style.left = '';
      bioWindow.style.transform = '';

      bioContainer.classList.remove('gui-hidden');
      bioContainer.classList.add('gui-visible');
    }

    function handleBioResponseKeydown(event) {
      if (event.key === 'Enter') {
        event.preventDefault();
        const responseInput = event.target; // The input span itself
        const response = responseInput.innerText.trim().toLowerCase();

        // Clean up: make non-editable and remove listener to prevent re-entry
        responseInput.contentEditable = 'false';
        responseInput.removeAttribute('id'); // Remove the ID to prevent duplicates
        responseInput.removeEventListener('keydown', handleBioResponseKeydown);
        bioAwaitingResponse = false;

        if (response === 'y' || response === 'yes') {
          typeNextBioPart();
        } else {
          const terminationMessage = document.createTextNode('\n\nBio reading terminated.');
          bioContent.appendChild(terminationMessage);
          bioFooter.innerHTML = `<span>-- End of Bio --</span>`;
        }
      }
    }

    function typeNextBioPart() {
      // Clear the footer before typing the next part
      bioFooter.innerHTML = '';

      if (currentBioPartIndex < bioParts.length) {
        let textToType = bioParts[currentBioPartIndex];
        const isFirstPart = currentBioPartIndex === 0;

        if (isFirstPart) {
          // Prepend the prompt character to the very first part
          textToType = `> ${textToType}`;
        } else {
          // For subsequent parts, add spacing
          bioContent.innerHTML += '\n\n';
        }

        let typewriterSpan = document.getElementById('bio-active-span');
        if (!typewriterSpan) {
          typewriterSpan = document.createElement('span');
          typewriterSpan.id = 'bio-active-span';
          if (isFirstPart) {
            // Apply a negative indent only to the first paragraph's span to pull the '>' to the edge.
            typewriterSpan.style.display = 'block';
            typewriterSpan.style.marginLeft = '-3px'; // Adjust as needed to align perfectly
          }
          bioContent.appendChild(typewriterSpan);
        }

        guiTypewriterEffect(textToType, typewriterSpan, () => {
          // onComplete callback
          typewriterSpan.removeAttribute('id'); // Clean up before moving on.
          currentBioPartIndex++;
          if (currentBioPartIndex < bioParts.length) {
            // More parts exist, show the input prompt.
            bioAwaitingResponse = true;
            // Wrap the prompt in a span for consistent styling with the first paragraph.
            const promptSpan = document.createElement('span');
            promptSpan.textContent = '\n\n> Would you like to continue reading? (y/n) ';

            const responseInput = document.createElement('span');
            responseInput.id = 'bio-response-input';
            responseInput.contentEditable = 'true';

            // Add the specific keydown listener for this input
            responseInput.addEventListener('keydown', handleBioResponseKeydown);

            bioContent.appendChild(promptSpan);
            bioContent.appendChild(responseInput);

          } else {
            // This was the last part
            bioFooter.innerHTML = `<span>-- End of Bio --</span>`;
          }
        });
      }
    }

    function hideBioWindow() {
      // Stop any bio process that might be running. This effectively "pauses" the typewriter.
      // The state (current text, current paragraph index) is preserved.
      if (bioTypingInterval) {
        clearInterval(bioTypingInterval);
        bioTypingInterval = null;
      }

      bioContainer.classList.add('gui-hidden');
      bioContainer.classList.remove('gui-visible');

      // Remove this window from the stack
      const index = windowStack.indexOf('bio-window');
      if (index > -1) {
        windowStack.splice(index, 1);
      }

      input.focus();
    }
    
    function simulateCommand(command) {
      appendTextToTerminal(`\n> ${command}\n`);
      commandHistory.push({ text: command, timestamp: new Date() });
      historyIndex = commandHistory.length;
      handleCommand(command);
      contentWrapper.scrollTop = contentWrapper.scrollHeight;
    }

    function typewriterEffect(text, onComplete) {
      if (activeTypingInterval) {
        clearInterval(activeTypingInterval);
      }
      let i = 0;
      input.contentEditable = 'false'; // Disable input while typing

      // Create a dedicated container for the typewriter text. This prevents
      // re-rendering the entire terminal on each character and is more performant.
      const typewriterContainer = document.createElement('span');
      terminal.appendChild(typewriterContainer);

      activeTypingInterval = setInterval(() => {
        if (i < text.length) {
          typewriterContainer.textContent += text.charAt(i);
          i++;
          contentWrapper.scrollTop = contentWrapper.scrollHeight;
        } else {
          clearInterval(activeTypingInterval);
          activeTypingInterval = null; // Reset the handle
          if (onComplete) onComplete();
        }
      }, 30); // Adjust typing speed here (in milliseconds)
    }

    // A simplified typewriter for GUI elements that doesn't affect the main terminal input.
    function guiTypewriterEffect(text, targetElement, onComplete) {
      // Stop any other bio typing process that might be running.
      if (bioTypingInterval) {
        clearInterval(bioTypingInterval);
      }

      // Start typing from the character after the last one already present.
      let i = targetElement.textContent.length;

      bioTypingInterval = setInterval(() => {
        if (i < text.length) {
          targetElement.textContent += text.charAt(i);
          i++;
        } else {
          clearInterval(bioTypingInterval);
          bioTypingInterval = null; // Reset the handle
          if (onComplete) onComplete();
        }
      }, 30);
    }

    function cancelCurrentProcess() {
      if (!awaitingResponseFor && !activeTypingInterval) {
        return false; // Nothing to cancel
      }

      if (activeTypingInterval) {
        clearInterval(activeTypingInterval);
        activeTypingInterval = null;
      }
      awaitingResponseFor = null;

      appendTextToTerminal(`\n\n[PROCESS CANCELLED]\nReturning to main prompt.\n`);
      input.contentEditable = 'true';
      input.focus();
      return true;
    }

    function moveCursorToEnd(element) {
      const range = document.createRange();
      const selection = window.getSelection();
      range.selectNodeContents(element);
      range.collapse(false); // false collapses to the end
      selection.removeAllRanges();
      selection.addRange(range);
      element.focus();
    }

    function downloadTranscript() {
      // We grab the innerText of the terminal, but add a final message.
      const transcriptContent = terminal.innerText + "\n\n--- TRANSCRIPT END ---";
      const blob = new Blob([transcriptContent], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      link.download = `terminal-session-${timestamp}.txt`;
      link.href = url;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      appendTextToTerminal(`\nDownloading transcript...`);
    }

    function makeDraggable(element, handle) {
      let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
      let dragStarted = false; // Flag to differentiate a drag from a scroll gesture

      const dragMouseDown = (e) => {
        // Prevent dragging when clicking on interactive elements (content, close button, resize handle)
        // Using classes makes this function reusable for any window.
        if (e.target.closest('.gui-content') || e.target.closest('.gui-close-button') || e.target.closest('.resize-handle')) {
          return;
        }

        // For mouse events, we start dragging immediately and prevent default text selection.
        if (e.type === 'mousedown') {
          e.preventDefault();
          dragStarted = true;
        }

        // If the element is centered via transform (from CSS), convert it to absolute pixel
        // positioning before dragging begins. This prevents a "jump" on the first interaction.
        // We check the computed style because the transform may not be an inline style.
        if (window.getComputedStyle(element).transform !== 'none') {
          const rect = element.getBoundingClientRect();
          element.style.transform = 'none';
          element.style.left = `${rect.left}px`;
          element.style.top = `${rect.top}px`;
        }

        // Get the initial cursor position
        if (e.type === 'touchstart') {
          pos3 = e.touches[0].clientX;
          pos4 = e.touches[0].clientY;
        } else {
          pos3 = e.clientX;
          pos4 = e.clientY;
        }

        document.addEventListener('mouseup', closeDragElement);
        document.addEventListener('touchend', closeDragElement);
        document.addEventListener('mousemove', elementDrag);
        // For touchmove, we need to be able to preventDefault, so passive: false is required.
        document.addEventListener('touchmove', elementDrag, { passive: false });
      };

      const elementDrag = (e) => {
        const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
        const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;

        // For touch events, we check if it's a real drag or just a scroll attempt
        if (e.type === 'touchmove' && !dragStarted) {
          const dx = Math.abs(clientX - pos3);
          const dy = Math.abs(clientY - pos4);

          // If the user moves more vertically than horizontally, assume it's a scroll
          // and not a drag. We then abort the drag sequence.
          if (dy > dx && dy > 5) { // 5px threshold
            closeDragElement();
            return;
          }
          // If movement is confirmed as a drag, set the flag.
          dragStarted = true;
        }

        // Once dragging has started, prevent default behavior (like page scroll).
        e.preventDefault();

        // Calculate the new cursor position
        pos1 = pos3 - clientX;
        pos2 = pos4 - clientY;
        pos3 = clientX;
        pos4 = clientY;
        // Set the element's new position
        element.style.top = (element.offsetTop - pos2) + "px";
        element.style.left = (element.offsetLeft - pos1) + "px";
      };

      const closeDragElement = () => {
        dragStarted = false; // Reset the flag
        document.removeEventListener('mouseup', closeDragElement);
        document.removeEventListener('touchend', closeDragElement);
        document.removeEventListener('mousemove', elementDrag);
        document.removeEventListener('touchmove', elementDrag);
      };

      handle.addEventListener('mousedown', dragMouseDown);
      // Make touchstart passive so it doesn't block scrolling while we decide if it's a drag.
      handle.addEventListener('touchstart', dragMouseDown, { passive: true });
    }

    function makeResizable(element) {
      let initialX, initialY, initialWidth, initialHeight, initialLeft;
      let direction = '';

      const resizeMouseDown = (e) => {
        e.preventDefault();
        e.stopPropagation(); // Prevent triggering the drag behavior on the parent

        // If the element is centered via transform (from CSS), convert it to absolute pixel
        // positioning before resizing begins. This prevents a "jump" on the first interaction.
        // We check the computed style because the transform may not be an inline style.
        if (window.getComputedStyle(element).transform !== 'none') {
          const rect = element.getBoundingClientRect();
          element.style.transform = 'none';
          element.style.left = `${rect.left}px`;
          element.style.top = `${rect.top}px`;
        }

        // --- FIX for WH window resize jump ---
        // First, lock the current rendered height as an inline style.
        // This prevents the window from suddenly expanding if its content is taller than its max-height.
        element.style.height = `${element.offsetHeight}px`;
        // Now, remove the max-height constraint so the user can resize freely beyond the initial limit.
        element.style.maxHeight = 'none';

        if (e.target.classList.contains('se')) {
          direction = 'se';
        } else if (e.target.classList.contains('sw')) {
          direction = 'sw';
        } else {
          return;
        }

        initialWidth = element.offsetWidth;
        initialHeight = element.offsetHeight;
        initialLeft = element.offsetLeft;

        if (e.type === 'touchstart') {
          initialX = e.touches[0].clientX;
          initialY = e.touches[0].clientY;
        } else {
          initialX = e.clientX;
          initialY = e.clientY;
        }

        document.addEventListener('mousemove', elementResize, { passive: false });
        document.addEventListener('touchmove', elementResize, { passive: false });
        document.addEventListener('mouseup', stopResize, { once: true });
        document.addEventListener('touchend', stopResize, { once: true });
      };

      const elementResize = (e) => {
        // Prevent page scroll on touch devices
        if (e.type === 'touchmove') {
          e.preventDefault();
        }

        const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
        const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;

        const dx = clientX - initialX;
        const dy = clientY - initialY;

        // Get min dimensions from CSS to make resizing more robust.
        const styles = window.getComputedStyle(element);
        const minWidth = parseInt(styles.minWidth, 10);
        const minHeight = parseInt(styles.minHeight, 10);

        const newHeight = initialHeight + dy;
        if (newHeight >= minHeight) {
          element.style.height = newHeight + 'px';
        }

        if (direction === 'se') {
          const newWidth = initialWidth + dx;
          if (newWidth >= minWidth) {
            element.style.width = newWidth + 'px';
          }
        } else if (direction === 'sw') {
          const newWidth = initialWidth - dx;
          if (newWidth >= minWidth) {
            element.style.width = newWidth + 'px';
            element.style.left = (initialLeft + dx) + 'px';
          }
        }
      };

      const stopResize = () => {
        document.removeEventListener('mousemove', elementResize);
        document.removeEventListener('touchmove', elementResize);
      };

      const handles = element.querySelectorAll('.resize-handle');
      handles.forEach(handle => {
        handle.addEventListener('mousedown', resizeMouseDown);
        handle.addEventListener('touchstart', resizeMouseDown);
      });
    }

    function handleResponse(response) {
      switch (awaitingResponseFor) {
        case 'transcript_prompt':
          if (response === 'y' || response === 'yes') {
            downloadTranscript();
          }
          // After handling the transcript, ask for final confirmation to exit.
          appendTextToTerminal(`\n\nAre you sure you want to terminate the session? (y/n)`);
          awaitingResponseFor = 'final_exit_confirm';
          break;
        case 'final_exit_confirm':
          if (response === 'y' || response === 'yes') {
            awaitingResponseFor = null;
            const exitMessage = `\n\nSESSION TERMINATED.\nGOODBYE.`;
            typewriterEffect(exitMessage, () => {
              // We visually end the session by fading to black. After the fade animation
              // completes, we will attempt to close the window.
              fadeOverlay.style.display = 'block';

              // Add a listener that will close the window once the fade is complete.
              fadeOverlay.addEventListener('transitionend', () => {
                window.close();
              }, { once: true });

              // A short delay ensures the 'display' change is rendered before the opacity transition starts.
              setTimeout(() => {
                fadeOverlay.style.opacity = '1';
              }, 50);
            });
          } else {
            appendTextToTerminal(`\nExit cancelled.\n`);
            awaitingResponseFor = null;
          }
          break;
      }
    }

    let historyIndex = 0;

    input.addEventListener('keydown', function(event) {
      // Use innerText for contenteditable div
      const rawInput = input.innerText;
      const currentInput = rawInput.trim();
      const currentInputLower = currentInput.toLowerCase();

      // Handle up/down arrow for command history
      if (event.key === 'ArrowUp') {
        event.preventDefault();
        if (historyIndex > 0) {
          historyIndex--;
          input.innerText = commandHistory[historyIndex].text;
          // Move cursor to the end of the input for a better user experience
          setTimeout(() => moveCursorToEnd(input), 0);
        }
      } else if (event.key === 'ArrowDown') {
        event.preventDefault();
        if (historyIndex < commandHistory.length - 1) {
          historyIndex++;
          input.innerText = commandHistory[historyIndex].text;
          setTimeout(() => moveCursorToEnd(input), 0);
        } else {
          // If we are at the end of history, going down again clears the input for a new command
          historyIndex = commandHistory.length;
          input.innerText = '';
        }
      }
      // Handle Tab for command completion
      else if (event.key === 'Tab') {
        event.preventDefault();
        if (currentInputLower === '') return;

        const allPossibleCommands = [...Object.keys(commands), ...Object.keys(commandAliases)];
        const matches = allPossibleCommands.filter(c => c.startsWith(currentInputLower));

        if (matches.length === 1) {
          input.innerText = matches[0];
          setTimeout(() => moveCursorToEnd(input), 0);
        } else if (matches.length > 1) {
          // Find the longest common prefix among all matches
          let sortedMatches = [...matches].sort();
          let first = sortedMatches[0];
          let last = sortedMatches[sortedMatches.length - 1];
          let i = 0;
          while (i < first.length && first.charAt(i) === last.charAt(i)) {
            i++;
          }
          const commonPrefix = first.substring(0, i);
          if (commonPrefix.length > currentInput.length) {
            input.innerText = commonPrefix;
            setTimeout(() => moveCursorToEnd(input), 0);
          }
        }
      }
      // Handle Enter to submit command
      else if (event.key === 'Enter') {
        event.preventDefault(); // Prevent adding a new line in the contenteditable div
        // On the first command, re-enable scrolling for the content area.
        contentWrapper.classList.remove('no-scroll-on-launch');

        if (currentInput === '') return;

        appendTextToTerminal(`\n> ${currentInput}`); // Display original casing

        const resolvedForCancel = commandAliases[currentInputLower] || currentInputLower;

        // --- Special 'cancel' command to interrupt processes ---
        if (resolvedForCancel === 'cancel') {
          if (!cancelCurrentProcess()) { // The typed command doesn't show ^C
            appendTextToTerminal(`\nNo active process to cancel.\n`);
          }
        } else if (awaitingResponseFor) {
          appendTextToTerminal(`\n`);
          handleResponse(currentInputLower);
        } else {
          appendTextToTerminal(`\n`);
          commandHistory.push({ text: currentInput, timestamp: new Date() });
          historyIndex = commandHistory.length; // Reset history index
          handleCommand(currentInputLower);
        }

        input.innerText = '';
        contentWrapper.scrollTop = contentWrapper.scrollHeight;
      }
    });

    const handlePicCloseClick = (event) => {
      event.preventDefault();
      hidePicWindow();
    };
    picCloseButton.addEventListener('click', handlePicCloseClick);
    picCloseButton.addEventListener('touchend', handlePicCloseClick);

    const handleBioCloseClick = (event) => {
      event.preventDefault();
      hideBioWindow();
    };
    bioCloseButton.addEventListener('click', handleBioCloseClick);
    bioCloseButton.addEventListener('touchend', handleBioCloseClick);

    // Add a listener to the bio content area to make it easier to focus the input.
    bioContent.addEventListener('click', (event) => {
      if (bioAwaitingResponse) {
        const responseInput = document.getElementById('bio-response-input');
        // If an input field exists, always focus it and move the cursor to the end.
        // This ensures correct behavior whether clicking the content area or the input itself.
        if (responseInput) {
          moveCursorToEnd(responseInput);
        }
      }
    });

    makeDraggable(document.getElementById('pic-window'), document.getElementById('pic-title-bar'));
    makeResizable(document.getElementById('pic-window'));

    makeDraggable(document.getElementById('bio-window'), document.getElementById('bio-title-bar'));
    makeResizable(document.getElementById('bio-window'));

    const commands = {
      help: () => {
        const isMobile = window.innerWidth <= 768; // Match the CSS breakpoint

        const commandToAliases = Object.entries(commandAliases).reduce((acc, [alias, command]) => {
          (acc[command] = acc[command] || []).push(alias);
          return acc;
        }, {});

        let helpText = 'AVAILABLE COMMANDS:\n\n';

        if (isMobile) {
          // Mobile-friendly stacked view for better readability
          const labelWidth = 10;
          Object.entries(commandDescriptions).forEach(([command, description]) => {
            const aliases = (commandToAliases[command] || []).join(', ');
            helpText += `${'COMMAND:'.padEnd(labelWidth)}${command}\n`;
            if (aliases) {
              helpText += `${'ALIASES:'.padEnd(labelWidth)}${aliases}\n`;
            }
            helpText += `${'DESC:'.padEnd(labelWidth)}${description}\n\n`;
          });
        } else {
          // Desktop table view
          const commandColWidth = 12;
          const aliasesColWidth = 15;

          helpText += 'COMMAND'.padEnd(commandColWidth) + 'ALIASES'.padEnd(aliasesColWidth) + 'DESCRIPTION\n';
          helpText += '-------'.padEnd(commandColWidth) + '-------'.padEnd(aliasesColWidth) + '-----------\n';

          Object.entries(commandDescriptions).forEach(([command, description]) => {
            const aliases = (commandToAliases[command] || []).join(', ');
            helpText += `${command.padEnd(commandColWidth)}${aliases.padEnd(aliasesColWidth)}${description}\n`;
          });
        }
        return helpText.trim();
      },
      bio: () => {
        showBioWindow();
        return "Launching bio viewer...";
      },
      contact: () => {
        const contactText = "Cell: 732-573-8567\nEmail: mattiglody@gmail.com";
        typewriterEffect(contactText, () => {
          // This function runs after the typing is complete
          appendTextToTerminal("\n"); // Add spacing after the contact info
          input.contentEditable = 'true'; // Re-enable the input field
          input.focus(); // Focus on the input field for the next command
          contentWrapper.scrollTop = contentWrapper.scrollHeight;
        });
        return null; // Signal that output is handled asynchronously
      },
      linkedin: () => {
        const url = 'https://www.linkedin.com/in/matthew-iglody/';
        window.open(url, '_blank');
        return "ACCESSING EXTERNAL LINK...\nREDIRECTING TO LINKEDIN PROFILE IN NEW TAB.";
      },
      pic: () => {
        showPicWindow();
        return "Launching image viewer...";
      },
      transfer: () => {
        const filePath = 'docs/Matthew_E_Iglody_2025_CV.pdf';
        // Open the file in a new tab. The browser's built-in PDF viewer will handle it.
        window.open(filePath, '_blank');
        return "ACCESSING DOCUMENT...\nOPENING CV IN NEW TAB.";
      },
      logs: () => {
        // Exclude the 'logs' command itself from the output for a cleaner history view.
        if (commandHistory.length <= 1) {
          return "No previous commands in history.";
        }
        return commandHistory.slice(0, -1).map(entry => {
          const time = entry.timestamp.toLocaleTimeString('en-US', { hour12: false });
          return `[${time}] ${entry.text}`;
        }).join("\n");
      },
      exit: () => {
        awaitingResponseFor = 'transcript_prompt';
        return "Would you like a transcript of your activity? (y/n)";
      },
    };

    function handleCommand(cmd) {
      const resolvedCmd = commandAliases[cmd] || cmd;

      // The 'clear' command is special as it modifies the terminal directly
      if (resolvedCmd === 'clear') {
        printWelcomeMessage();
        hidePicWindow();
        hideBioWindow();
        return;
      }

      const commandFn = commands[resolvedCmd];
      if (!commandFn) {
        appendTextToTerminal(`Unrecognized command: '${cmd}'\nType 'help' (or 'h') for options.\n`);
        return;
      }

      const output = commandFn();

      // If a command returns null, it handles its own output (e.g., typewriter)
      if (output === null) return;

      // Add a single newline for consistent spacing before the next prompt.
      appendTextToTerminal(output + "\n");
    }

    // --- INITIALIZATION ---
    printWelcomeMessage();
    contentWrapper.classList.add('no-scroll-on-launch');
  </script>
</body>
</html>
